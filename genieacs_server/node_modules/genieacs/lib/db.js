// Generated by CoffeeScript 1.12.7

/*
 * Copyright 2013-2017  Zaid Abdulla
 *
 * This file is part of GenieACS.
 *
 * GenieACS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * GenieACS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with GenieACS.  If not, see <http://www.gnu.org/licenses/>.
 */
var clearTasks, common, config, connect, deleteFault, deleteOperation, devicesCollection, disconnect, faultsCollection, fetchDevice, filesCollection, getDueTasks, getFaults, getFiles, getObjects, getOperations, getPresets, getProvisions, getVirtualParameters, mongodb, objectsCollection, operationsCollection, optimizeProjection, presetsCollection, provisionsCollection, saveDevice, saveFault, saveOperation, tasksCollection, virtualParametersCollection;

config = require('./config');

mongodb = require('mongodb');

common = require('./common');

tasksCollection = null;

devicesCollection = null;

presetsCollection = null;

objectsCollection = null;

provisionsCollection = null;

virtualParametersCollection = null;

faultsCollection = null;

filesCollection = null;

operationsCollection = null;

connect = function(callback) {
  var callbackCounter;
  callbackCounter = 9;
  return mongodb.MongoClient.connect(config.get('MONGODB_CONNECTION_URL'), function(err, db) {
    if (err) {
      return callback(err);
    }
    exports.mongoDb = db;
    db.collection('tasks', function(err, collection) {
      exports.tasksCollection = tasksCollection = collection;
      if (collection != null) {
        collection.ensureIndex({
          device: 1,
          timestamp: 1
        }, function(err) {});
      }
      if (--callbackCounter === 0 || err) {
        callbackCounter = 0;
        return callback(err);
      }
    });
    db.collection('devices', function(err, collection) {
      exports.devicesCollection = devicesCollection = collection;
      if (--callbackCounter === 0 || err) {
        callbackCounter = 0;
        return callback(err);
      }
    });
    db.collection('presets', function(err, collection) {
      exports.presetsCollection = presetsCollection = collection;
      if (--callbackCounter === 0 || err) {
        callbackCounter = 0;
        return callback(err);
      }
    });
    db.collection('objects', function(err, collection) {
      exports.objectsCollection = objectsCollection = collection;
      if (--callbackCounter === 0 || err) {
        callbackCounter = 0;
        return callback(err);
      }
    });
    db.collection('fs.files', function(err, collection) {
      exports.filesCollection = filesCollection = collection;
      if (--callbackCounter === 0 || err) {
        callbackCounter = 0;
        return callback(err);
      }
    });
    db.collection('provisions', function(err, collection) {
      exports.provisionsCollection = provisionsCollection = collection;
      if (--callbackCounter === 0 || err) {
        callbackCounter = 0;
        return callback(err);
      }
    });
    db.collection('virtualParameters', function(err, collection) {
      exports.virtualParametersCollection = virtualParametersCollection = collection;
      if (--callbackCounter === 0 || err) {
        callbackCounter = 0;
        return callback(err);
      }
    });
    db.collection('faults', function(err, collection) {
      exports.faultsCollection = faultsCollection = collection;
      if (--callbackCounter === 0 || err) {
        callbackCounter = 0;
        return callback(err);
      }
    });
    return db.collection('operations', function(err, collection) {
      exports.operationsCollection = operationsCollection = collection;
      if (--callbackCounter === 0 || err) {
        callbackCounter = 0;
        return callback(err);
      }
    });
  });
};

disconnect = function() {
  var ref;
  return (ref = exports.mongoDb) != null ? ref.close() : void 0;
};

optimizeProjection = function(obj) {
  var a, b, i, keys;
  if (obj['']) {
    return {
      '': obj['']
    };
  }
  keys = Object.keys(obj).sort();
  if (keys.length <= 1) {
    return obj;
  }
  i = 1;
  while (i < keys.length) {
    a = keys[i - 1];
    b = keys[i];
    if (b.startsWith(a)) {
      if (b.charAt(a.length) === '.' || b.charAt(a.length - 1) === '.') {
        delete obj[b];
        keys.splice(i--, 1);
      }
    }
    ++i;
  }
  return obj;
};

fetchDevice = function(id, timestamp, patterns, callback) {
  var MAX_DEPTH, func, k, loaded, proj, projection, projectionTree, res, v;
  MAX_DEPTH = config.get('MAX_DEPTH', id);
  if (!(patterns != null ? patterns.length : void 0)) {
    patterns = [[[], (1 << MAX_DEPTH) - 1]];
  }
  projection = {};
  projectionTree = {};
  func = function(path, pats, projTree) {
    var children, fragment, j, k, len, pat, results, v;
    children = {};
    for (j = 0, len = pats.length; j < len; j++) {
      pat = pats[j];
      fragment = pat[0][path.length] || '*';
      if (fragment === '*') {
        if (pat[1] << path.length) {
          projection[path.join('.')] = 1;
        }
        return;
      }
      if (projTree[fragment] == null) {
        projTree[fragment] = {};
      }
      if (pat[1] & (1 << path.length)) {
        projection[path.concat('_timestamp').join('.')] = 1;
        projection[path.concat('_object').join('.')] = 1;
        projection[path.concat('_instance').join('.')] = 1;
        projection[path.concat([fragment, '_timestamp']).join('.')] = 1;
        projection[path.concat([fragment, '_value']).join('.')] = 1;
        projection[path.concat([fragment, '_type']).join('.')] = 1;
        projection[path.concat([fragment, '_object']).join('.')] = 1;
        projection[path.concat([fragment, '_instance']).join('.')] = 1;
        projection[path.concat([fragment, '_writable']).join('.')] = 1;
        projection[path.concat([fragment, '_orig']).join('.')] = 1;
      }
      if (pat[1] >> (path.length + 1)) {
        if (children[fragment] == null) {
          children[fragment] = [];
        }
        children[fragment].push(pat);
      }
    }
    results = [];
    for (k in children) {
      v = children[k];
      results.push(func(path.concat(k), v, projTree[k]));
    }
    return results;
  };
  func([], patterns, projectionTree);
  delete projectionTree['DeviceID'];
  delete projectionTree['Events'];
  delete projectionTree['Tags'];
  res = [];
  loaded = [];
  projection = optimizeProjection(projection);
  for (k in projection) {
    v = projection[k];
    if (k === '' || k === 'Events' || k.startsWith('Events.')) {
      if (k === '' || k === 'Events' || k === 'Events._writable') {
        res.push([
          ['Events'], timestamp, {
            object: [timestamp, 1],
            writable: [timestamp, 0]
          }
        ]);
        if (k === 'Events._writable') {
          loaded.push([['Events'], 1]);
        }
      }
      if (k === 'Events') {
        projection['_lastInform'] = 1;
        projection['_lastBoot'] = 1;
        projection['_lastBootstrap'] = 1;
        projection['_registered'] = 1;
        loaded.push([['Events'], (1 << MAX_DEPTH) - 1]);
      } else if (k === 'Events.Inform._writable' || k === 'Events.Inform') {
        projection['_lastInform'] = 1;
        loaded.push([['Events', 'Inform'], 1 ^ ((1 << MAX_DEPTH) - 1)]);
      } else if (k === 'Events.1_BOOT._writable' || k === 'Events.1_BOOT') {
        projection['_lastBoot'] = 1;
        loaded.push([['Events', '1_BOOT'], 1 ^ ((1 << MAX_DEPTH) - 1)]);
      } else if (k === 'Events.0_BOOTSTRAP._writable' || k === 'Events.0_BOOTSTRAP') {
        projection['_lastBootstrap'] = 1;
        loaded.push([['Events', '0_BOOTSTRAP'], 1 ^ ((1 << MAX_DEPTH) - 1)]);
      } else if (k === 'Events.Registered._writable' || k === 'Events.Registered') {
        projection['_registered'] = 1;
        loaded.push([['Events', 'Registered'], 1 ^ ((1 << MAX_DEPTH) - 1)]);
      } else if (k.endsWith('._writable') && k !== 'Events._writable') {
        loaded.push([k.split('.').slice(0, 2), 1 ^ ((1 << MAX_DEPTH) - 1)]);
      }
      if (k !== '') {
        delete projection[k];
      }
    }
    if (k === '' || k === 'DeviceID' || k.startsWith('DeviceID.')) {
      if (k === '' || k === 'DeviceID' || k === 'DeviceID._writable') {
        res.push([
          ['DeviceID'], timestamp, {
            object: [timestamp, 1],
            writable: [timestamp, 0]
          }
        ]);
        if (k === 'DeviceID._writable') {
          loaded.push([['DeviceID'], 1]);
        }
      }
      if (k === 'DeviceID') {
        projection['_id'] = 1;
        projection['_deviceId'] = 1;
        loaded.push([['DeviceID'], (1 << MAX_DEPTH) - 1]);
      } else if (k === 'DeviceID.ID._writable' || k === 'DeviceID.ID') {
        projection['_id'] = 1;
        loaded.push([['DeviceID', 'ID'], 1 ^ ((1 << MAX_DEPTH) - 1)]);
      } else if (k === 'DeviceID.Manufacturer._writable' || k === 'DeviceID.DeManufacturer') {
        projection['_deviceId._Manufacturer'] = 1;
        loaded.push([['DeviceID', 'Manufacturer'], 1 ^ ((1 << MAX_DEPTH) - 1)]);
      } else if (k === 'DeviceID.ProductClass._writable' || k === 'DeviceID.ProductClass') {
        projection['_deviceId._ProductClass'] = 1;
        loaded.push([['DeviceID', 'ProductClass'], 1 ^ ((1 << MAX_DEPTH) - 1)]);
      } else if (k === 'DeviceID.OUI._writable' || k === 'DeviceID.OUI') {
        projection['_deviceId._OUI'] = 1;
        loaded.push([['DeviceID', 'ProductClass'], 1 ^ ((1 << MAX_DEPTH) - 1)]);
      } else if (k === 'DeviceID.SerialNumber._writable' || k === 'DeviceID.SerialNumber') {
        projection['_deviceId._SerialNumber'] = 1;
        loaded.push([['DeviceID', 'SerialNumber'], 1 ^ ((1 << MAX_DEPTH) - 1)]);
      } else if (k.endsWith('._writable') && k !== 'DeviceID._writable') {
        loaded.push([k.split('.').slice(0, 2), 1 ^ ((1 << MAX_DEPTH) - 1)]);
      }
      if (k !== '') {
        delete projection[k];
      }
    }
    if (k === 'Tags' || k.startsWith('Tags.')) {
      if (!projection['_tags']) {
        projection['_tags'] = 1;
        loaded.push([['Tags'], (1 << MAX_DEPTH) - 1]);
      }
      delete projection[k];
    }
  }
  if (projection['']) {
    proj = {};
  } else if (Object.keys(projection).length === 0) {
    proj = {
      '_id': 1
    };
  } else {
    proj = projection;
  }
  return devicesCollection.findOne({
    '_id': id
  }, proj, function(err, device) {
    var j, len, storeParams, t;
    if (err || (device == null)) {
      return callback(err);
    }
    storeParams = function(obj, path, timestamp, descendantsFetched, projTree) {
      var attrs, kk, p, results, t, thisFetched;
      if (descendantsFetched) {
        thisFetched = true;
      } else {
        if (projection[path.join('.')]) {
          descendantsFetched = true;
          if (path.length && projection[path.slice(0, -1).concat("_timestamp").join('.')]) {
            thisFetched = true;
            loaded.push([path, ((1 << (path.length - 1)) - 1) ^ ((1 << MAX_DEPTH) - 1)]);
          } else {
            loaded.push([path, ((1 << path.length) - 1) ^ ((1 << MAX_DEPTH) - 1)]);
          }
        } else if (projection[path.concat('_writable').join('.')]) {
          loaded.push([path, 1 << (path.length - 1)]);
          thisFetched = true;
        }
      }
      if (obj['_timestamp'] != null) {
        obj['_timestamp'] = +obj['_timestamp'];
      }
      if (obj['_instance'] && (obj['_object'] == null)) {
        obj['_object'] = true;
      }
      if (thisFetched) {
        attrs = {};
        t = obj['_timestamp'] || 1;
        if (timestamp > t) {
          t = timestamp;
        }
        if (obj['_value'] != null) {
          attrs.value = [obj['_timestamp'] || 1, [obj['_value'], obj['_type']]];
          if (obj['_type'] === 'xsd:dateTime') {
            attrs.value[1][0] = +attrs.value[1][0];
          }
          obj['_object'] = false;
        }
        if (obj['_writable'] != null) {
          attrs.writable = [timestamp || 1, obj['_writable'] ? 1 : 0];
        }
        if (obj['_object'] != null) {
          attrs.object = [t, obj['_object'] ? 1 : 0];
        }
        res.push([path, t, attrs]);
      }
      for (k in obj) {
        v = obj[k];
        if (!k.startsWith('_')) {
          kk = k;
          obj['_object'] = true;
          storeParams(v, path.concat(k), obj['_timestamp'], descendantsFetched, projTree != null ? projTree[k] : void 0);
          if (projTree) {
            delete projTree[kk];
          }
        }
      }
      if (!descendantsFetched) {
        results = [];
        for (k in projTree) {
          v = projTree[k];
          p = path.concat(k);
          loaded.push([p, ((1 << path.length) - 1) ^ ((1 << MAX_DEPTH) - 1)]);
          if ((obj['_object'] || path.length === 0) && obj['_timestamp']) {
            results.push(res.push([p, obj['_timestamp']]));
          } else {
            results.push(void 0);
          }
        }
        return results;
      } else if ((obj['_object'] || path.length === 0) && obj['_timestamp']) {
        return res.push([path.concat('*'), obj['_timestamp']]);
      }
    };
    for (k in device) {
      v = device[k];
      switch (k) {
        case '_lastInform':
          res.push([
            ['Events', 'Inform'], +v, {
              object: [+v, 0],
              writable: [+v, 0],
              value: [+v, [+v, 'xsd:dateTime']]
            }
          ]);
          delete device[k];
          break;
        case '_lastBoot':
          res.push([
            ['Events', '1_BOOT'], +v, {
              object: [+v, 0],
              writable: [+v, 0],
              value: [+v, [+v, 'xsd:dateTime']]
            }
          ]);
          delete device[k];
          break;
        case '_lastBootstrap':
          res.push([
            ['Events', '0_BOOTSTRAP'], +v, {
              object: [+v, 0],
              writable: [+v, 0],
              value: [+v, [+v, 'xsd:dateTime']]
            }
          ]);
          delete device[k];
          break;
        case '_registered':
          res.push([
            ['Events', 'Registered'], timestamp, {
              object: [timestamp, 0],
              writable: [timestamp, 0],
              value: [timestamp, [+v, 'xsd:dateTime']]
            }
          ]);
          delete device[k];
          break;
        case '_id':
          if (projection[''] || projection['_id']) {
            res.push([
              ['DeviceID', 'ID'], timestamp, {
                object: [timestamp, 0],
                writable: [timestamp, 0],
                value: [timestamp, [v, 'xsd:string']]
              }
            ]);
          }
          delete device[k];
          break;
        case '_tags':
          if (v.length) {
            res.push([
              ['Tags'], timestamp, {
                object: [timestamp, 1],
                writable: [timestamp, 0]
              }
            ]);
          }
          for (j = 0, len = v.length; j < len; j++) {
            t = v[j];
            t = t.replace(/[^a-zA-Z0-9\-]+/g, '_');
            res.push([
              ['Tags', t], timestamp, {
                object: [timestamp, 0],
                writable: [timestamp, 1],
                value: [timestamp, [true, 'xsd:boolean']]
              }
            ]);
          }
          delete device[k];
          break;
        case '_deviceId':
          if (v['_Manufacturer'] != null) {
            res.push([
              ['DeviceID', 'Manufacturer'], timestamp, {
                object: [timestamp, 0],
                writable: [timestamp, 0],
                value: [timestamp, [v['_Manufacturer'], 'xsd:string']]
              }
            ]);
          }
          if (v['_OUI'] != null) {
            res.push([
              ['DeviceID', 'OUI'], timestamp, {
                object: [timestamp, 0],
                writable: [timestamp, 0],
                value: [timestamp, [v['_OUI'], 'xsd:string']]
              }
            ]);
          }
          if (v['_ProductClass'] != null) {
            res.push([
              ['DeviceID', 'ProductClass'], timestamp, {
                object: [timestamp, 0],
                writable: [timestamp, 0],
                value: [timestamp, [v['_ProductClass'], 'xsd:string']]
              }
            ]);
          }
          if (v['_SerialNumber'] != null) {
            res.push([
              ['DeviceID', 'SerialNumber'], timestamp, {
                object: [timestamp, 0],
                writable: [timestamp, 0],
                value: [timestamp, [v['_SerialNumber'], 'xsd:string']]
              }
            ]);
          }
          delete device[k];
      }
    }
    storeParams(device, [], 0, false, projectionTree);
    return callback(null, res, loaded);
  });
};

saveDevice = function(deviceId, deviceData, isNew, sessionTimestamp, callback) {
  var attrName, base, base1, diff, iter, k, kk, parent, path, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref2, ref20, ref21, ref22, ref23, ref24, ref25, ref26, ref27, ref28, ref29, ref3, ref30, ref31, ref4, ref5, ref6, ref7, ref8, ref9, t, update, update2, v;
  update = {
    '$set': {},
    '$unset': {},
    '$addToSet': {},
    '$pull': {}
  };
  iter = deviceData.timestamps.diff();
  while (diff = iter.next().value) {
    if (diff[0].wildcard !== (1 << (diff[0].length - 1))) {
      continue;
    }
    if ((ref = diff[0][0]) === 'Events' || ref === 'DeviceID' || ref === 'Tags') {
      continue;
    }
    if (diff[2] > sessionTimestamp) {
      diff[2] = sessionTimestamp;
    }
    if ((diff[2] == null) && (diff[1] != null)) {
      update['$unset'][diff[0].slice(0, -1).concat('_timestamp').join('.')] = 1;
    } else if (diff[2] !== diff[1]) {
      parent = deviceData.paths.get(diff[0].slice(0, -1));
      if (parent && (parent.length === 0 || deviceData.attributes.has(parent))) {
        update['$set'][diff[0].slice(0, -1).concat('_timestamp').join('.')] = new Date(diff[2]);
      }
    }
  }
  iter = deviceData.attributes.diff();
  while (diff = iter.next().value) {
    if (diff[1] === diff[2]) {
      continue;
    }
    path = diff[0];
    switch (path[0]) {
      case 'Events':
        if (diff[0].length === 2 && ((ref1 = diff[2]) != null ? (ref2 = ref1.value) != null ? ref2[1][0] : void 0 : void 0) !== ((ref3 = diff[1]) != null ? (ref4 = ref3.value) != null ? ref4[1][0] : void 0 : void 0)) {
          if (!diff[2]) {
            switch (path[1]) {
              case 'Inform':
                update['$unset']['_lastInform'] = 1;
                break;
              case '1_BOOT':
                update['$unset']['_lastBoot'] = 1;
                break;
              case '0_BOOTSTRAP':
                update['$unset']['_lastBootstrap'] = 1;
                break;
              case 'Registered':
                update['$unset']['_registered'] = 1;
            }
          } else {
            t = new Date(diff[2].value[1][0]);
            switch (path[1]) {
              case 'Inform':
                update['$set']['_lastInform'] = t;
                break;
              case '1_BOOT':
                update['$set']['_lastBoot'] = t;
                break;
              case '0_BOOTSTRAP':
                update['$set']['_lastBootstrap'] = t;
                break;
              case 'Registered':
                update['$set']['_registered'] = t;
            }
          }
        }
        break;
      case 'DeviceID':
        if (((ref5 = diff[2].value) != null ? (ref6 = ref5[1]) != null ? ref6[0] : void 0 : void 0) !== ((ref7 = diff[1]) != null ? (ref8 = ref7.value) != null ? (ref9 = ref8[1]) != null ? ref9[0] : void 0 : void 0 : void 0)) {
          v = diff[2].value[1][0];
          switch (path[1]) {
            case 'ID':
              update['$set']['_id'] = v;
              break;
            case 'Manufacturer':
              update['$set']['_deviceId._Manufacturer'] = v;
              break;
            case 'OUI':
              update['$set']['_deviceId._OUI'] = v;
              break;
            case 'ProductClass':
              update['$set']['_deviceId._ProductClass'] = v;
              break;
            case 'SerialNumber':
              update['$set']['_deviceId._SerialNumber'] = v;
          }
        }
        break;
      case 'Tags':
        if (((ref10 = diff[2]) != null ? (ref11 = ref10.value) != null ? (ref12 = ref11[1]) != null ? ref12[0] : void 0 : void 0 : void 0) !== ((ref13 = diff[1]) != null ? (ref14 = ref13.value) != null ? (ref15 = ref14[1]) != null ? ref15[0] : void 0 : void 0 : void 0)) {
          v = (ref16 = diff[2]) != null ? (ref17 = ref16.value) != null ? ref17[1][0] : void 0 : void 0;
          if (v != null) {
            if ((base = update['$addToSet'])['_tags'] == null) {
              base['_tags'] = {
                '$each': []
              };
            }
            update['$addToSet']['_tags']['$each'].push(diff[0][1]);
          } else {
            if ((base1 = update['$pull'])['_tags'] == null) {
              base1['_tags'] = {
                '$in': []
              };
            }
            update['$pull']['_tags']['$in'].push(diff[0][1]);
          }
        }
        break;
      default:
        if (!diff[2]) {
          update['$unset'][diff[0].join('.')] = 1;
          continue;
        }
        for (attrName in diff[2]) {
          if (diff[2][attrName][0] > sessionTimestamp) {
            diff[2][attrName][0] = sessionTimestamp;
          }
          if (diff[2][attrName][1] != null) {
            switch (attrName) {
              case 'value':
                if (diff[2].value[1][0] !== ((ref18 = diff[1]) != null ? (ref19 = ref18.value) != null ? (ref20 = ref19[1]) != null ? ref20[0] : void 0 : void 0 : void 0)) {
                  if (diff[2].value[1][1] === 'xsd:dateTime' && Number.isInteger(diff[2].value[1][0])) {
                    update['$set'][path.concat('_value').join('.')] = new Date(diff[2].value[1][0]);
                  } else {
                    update['$set'][path.concat('_value').join('.')] = diff[2].value[1][0];
                  }
                }
                if (diff[2].value[1][1] !== ((ref21 = diff[1]) != null ? (ref22 = ref21.value) != null ? (ref23 = ref22[1]) != null ? ref23[1] : void 0 : void 0 : void 0)) {
                  update['$set'][path.concat('_type').join('.')] = diff[2].value[1][1];
                }
                if (diff[2].value[0] !== ((ref24 = diff[1]) != null ? (ref25 = ref24.value) != null ? ref25[0] : void 0 : void 0)) {
                  update['$set'][path.concat('_timestamp').join('.')] = new Date(diff[2].value[0]);
                }
                break;
              case 'object':
                if (!((ref26 = diff[1]) != null ? ref26.object : void 0) || diff[2].object[1] !== ((ref27 = diff[1].object) != null ? ref27[1] : void 0)) {
                  update['$set'][path.concat('_object').join('.')] = !!diff[2].object[1];
                }
                break;
              case 'writable':
                if (!((ref28 = diff[1]) != null ? ref28.writable : void 0) || diff[2].writable[1] !== ((ref29 = diff[1].writable) != null ? ref29[1] : void 0)) {
                  update['$set'][path.concat('_writable').join('.')] = !!diff[2].writable[1];
                }
            }
          }
        }
        if (diff[1]) {
          for (attrName in diff[1]) {
            if ((diff[1][attrName][1] != null) && (((ref30 = diff[2]) != null ? (ref31 = ref30[attrName]) != null ? ref31[1] : void 0 : void 0) == null)) {
              update['$unset'][path.concat("_" + attrName).join('.')] = 1;
              if (attrName === 'value') {
                update['$unset'][path.concat('_type').join('.')] = 1;
                update['$unset'][path.concat('_timestamp').join('.')] = 1;
              }
            }
          }
        }
    }
  }
  update['$unset'] = optimizeProjection(update['$unset']);
  for (k in update['$unset']) {
    if (update['$set'][k] != null) {
      delete update['$unset'][k];
    }
  }
  for (k in update) {
    if (k === '$addToSet') {
      for (kk in update[k]) {
        if (update[k][kk]['$each'].length === 0) {
          delete update[k][kk];
        }
      }
    } else if (k === '$pull') {
      for (kk in update[k]) {
        if (update[k][kk]['$in'].length === 0) {
          delete update[k][kk];
        }
      }
    }
    if (Object.keys(update[k]).length === 0) {
      delete update[k];
    }
  }
  if (Object.keys(update).length === 0) {
    return callback();
  }
  if (update['$addToSet'] && update['$pull']) {
    update2 = {
      '$pull': update['$pull']
    };
    delete update['$pull'];
  }
  return devicesCollection.update({
    '_id': deviceId
  }, update, {
    upsert: isNew
  }, function(err, result) {
    if (!err && result.result.n !== 1) {
      return callback(new Error("Device " + deviceId + " not found in database"));
    }
    if (update2) {
      return devicesCollection.update({
        '_id': deviceId
      }, update2, callback);
    }
    return callback(err);
  });
};

getFaults = function(deviceId, callback) {
  return faultsCollection.find({
    '_id': {
      '$regex': "^" + (common.escapeRegExp(deviceId)) + "\\:"
    }
  }).toArray(function(err, res) {
    var channel, faults, j, len, r;
    if (err) {
      return callback(err);
    }
    faults = {};
    for (j = 0, len = res.length; j < len; j++) {
      r = res[j];
      channel = r._id.slice(deviceId.length + 1);
      delete r._id;
      delete r.channel;
      delete r.device;
      r.timestamp = +r.timestamp;
      r.provisions = JSON.parse(r.provisions);
      faults[channel] = r;
    }
    return callback(err, faults);
  });
};

saveFault = function(deviceId, channel, fault, callback) {
  fault = Object.assign({}, fault);
  fault._id = deviceId + ":" + channel;
  fault.device = deviceId;
  fault.channel = channel;
  fault.timestamp = new Date(fault.timestamp);
  fault.provisions = JSON.stringify(fault.provisions);
  return faultsCollection.save(fault, callback);
};

deleteFault = function(deviceId, channel, callback) {
  return faultsCollection.remove({
    _id: deviceId + ":" + channel
  }, callback);
};

getDueTasks = function(deviceId, timestamp, callback) {
  var cur, f, tasks;
  cur = tasksCollection.find({
    'device': deviceId
  }).sort(['timestamp']);
  tasks = [];
  return cur.nextObject(f = function(err, task) {
    var q;
    if (err) {
      return callback(err);
    }
    if (task == null) {
      return callback(null, tasks, null);
    }
    if (task.timestamp != null) {
      task.timestamp = +task.timestamp;
    }
    if (task.expiry != null) {
      task.expiry = +task.expiry;
    }
    if (task.timestamp >= timestamp) {
      return callback(null, tasks, +task.timestamp);
    }
    task._id = String(task._id);
    tasks.push(task);
    if (task.name === 'download' && (task.file != null)) {
      if (mongodb.ObjectID.isValid(task.file)) {
        q = {
          _id: {
            '$in': [task.file, new mongodb.ObjectID(task.file)]
          }
        };
      } else {
        q = {
          _id: task.file
        };
      }
      return filesCollection.find(q).toArray(function(err, res) {
        if (err) {
          return callback(err);
        }
        if (res[0] != null) {
          if (task.fileType == null) {
            task.fileType = res[0].metadata.fileType;
          }
          if (task.fileName == null) {
            task.fileName = res[0].filename || res[0]._id.toString();
          }
        }
        return cur.nextObject(f);
      });
    } else {
      return cur.nextObject(f);
    }
  });
};

clearTasks = function(deviceId, taskIds, callback) {
  var id;
  return tasksCollection.remove({
    '_id': {
      '$in': (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = taskIds.length; j < len; j++) {
          id = taskIds[j];
          results.push(new mongodb.ObjectID(id));
        }
        return results;
      })()
    }
  }, callback);
};

getOperations = function(deviceId, callback) {
  return operationsCollection.find({
    '_id': {
      '$regex': "^" + (common.escapeRegExp(deviceId)) + "\\:"
    }
  }).toArray(function(err, res) {
    var commandKey, j, len, operations, r;
    if (err) {
      return callback(err);
    }
    operations = {};
    for (j = 0, len = res.length; j < len; j++) {
      r = res[j];
      commandKey = r._id.slice(deviceId.length + 1);
      delete r._id;
      r.timestamp = +r.timestamp;
      if (r.args) {
        r.args = JSON.parse(r.args);
      }
      r.provisions = JSON.parse(r.provisions);
      r.retries = JSON.parse(r.retries);
      operations[commandKey] = r;
    }
    return callback(err, operations);
  });
};

saveOperation = function(deviceId, commandKey, operation, callback) {
  operation = Object.assign({}, operation);
  operation._id = deviceId + ":" + commandKey;
  operation.timestamp = new Date(operation.timestamp);
  operation.provisions = JSON.stringify(operation.provisions);
  operation.retries = JSON.stringify(operation.retries);
  operation.args = JSON.stringify(operation.args);
  return operationsCollection.save(operation, callback);
};

deleteOperation = function(deviceId, commandKey, callback) {
  return operationsCollection.remove({
    _id: deviceId + ":" + commandKey
  }, callback);
};

getPresets = function(callback) {
  return presetsCollection.find().toArray(callback);
};

getObjects = function(callback) {
  return objectsCollection.find().toArray(callback);
};

getProvisions = function(callback) {
  return provisionsCollection.find().toArray(callback);
};

getVirtualParameters = function(callback) {
  return virtualParametersCollection.find().toArray(callback);
};

getFiles = function(callback) {
  return filesCollection.find().toArray(callback);
};

exports.connect = connect;

exports.disconnect = disconnect;

exports.fetchDevice = fetchDevice;

exports.saveDevice = saveDevice;

exports.getFaults = getFaults;

exports.saveFault = saveFault;

exports.deleteFault = deleteFault;

exports.clearTasks = clearTasks;

exports.saveOperation = saveOperation;

exports.deleteOperation = deleteOperation;

exports.getPresets = getPresets;

exports.getObjects = getObjects;

exports.getProvisions = getProvisions;

exports.getVirtualParameters = getVirtualParameters;

exports.getFiles = getFiles;

exports.getDueTasks = getDueTasks;

exports.getOperations = getOperations;
