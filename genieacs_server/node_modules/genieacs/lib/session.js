// Generated by CoffeeScript 1.12.7

/*
 * Copyright 2013-2017  Zaid Abdulla
 *
 * This file is part of GenieACS.
 *
 * GenieACS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * GenieACS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with GenieACS.  If not, see <http://www.gnu.org/licenses/>.
 */
var InstanceSet, MAX_ITERATIONS, PathSet, VersionedMap, addProvisions, clear, clearProvisions, common, config, db, defaultProvisions, deserialize, device, generateGetRpcRequest, generateGetVirtualParameterProvisions, generateRpcId, generateSetRpcRequest, generateSetVirtualParameterProvisions, gpnHeuristic, inform, init, initDeviceData, loadParameters, loadPath, localCache, processDeclarations, processInstances, provisionsCache, revertDownloadParameters, rpcFault, rpcRequest, rpcResponse, runDeclarations, runProvisions, runVirtualParameters, sandbox, serialize, timeoutOperations, transferComplete, virtualParametersCache;

config = require('./config');

common = require('./common');

db = require('./db');

device = require('./device');

sandbox = require('./sandbox');

localCache = require('./local-cache');

PathSet = require('./path-set');

VersionedMap = require('./versioned-map');

InstanceSet = require('./instance-set');

defaultProvisions = require('./default-provisions');

gpnHeuristic = require('./gpn-heuristic');

MAX_ITERATIONS = config.get('MAX_COMMIT_ITERATIONS') * 2;

provisionsCache = new WeakMap();

virtualParametersCache = new WeakMap();

initDeviceData = function() {
  return {
    paths: new PathSet(),
    timestamps: new VersionedMap(),
    attributes: new VersionedMap(),
    loaded: new Map(),
    trackers: new Map(),
    changes: new Set()
  };
};

init = function(deviceId, cwmpVersion, timeout, callback) {
  var sessionContext, timestamp;
  timestamp = Date.now();
  sessionContext = {
    timestamp: timestamp,
    deviceId: deviceId,
    deviceData: initDeviceData(),
    cwmpVersion: cwmpVersion,
    timeout: timeout,
    provisions: [],
    channels: {},
    virtualParameters: [],
    revisions: [0],
    rpcCount: 0,
    iteration: 0,
    cycle: 0,
    extensionsCache: {},
    declarations: []
  };
  return localCache.getProvisionsAndVirtualParameters(function(err, hash, provisions, virtualParameters) {
    if (err) {
      return callback(err);
    }
    sessionContext.presetsHash = hash;
    provisionsCache.set(sessionContext, provisions);
    virtualParametersCache.set(sessionContext, virtualParameters);
    return callback(null, sessionContext);
  });
};

loadParameters = function(sessionContext, callback) {
  var ref, toLoad;
  if (!((ref = sessionContext.toLoad) != null ? ref.size : void 0)) {
    return callback();
  }
  toLoad = Array.from(sessionContext.toLoad.entries());
  return db.fetchDevice(sessionContext.deviceId, sessionContext.timestamp, toLoad, function(err, parameters, loaded) {
    var l, len, len1, m, o, p, path;
    if (err) {
      return callback(err);
    }
    if (parameters == null) {
      sessionContext["new"] = true;
      loaded = [[[], (1 << config.get('MAX_DEPTH', sessionContext.deviceId)) - 1]];
      parameters = [];
    }
    for (m = 0, len = loaded.length; m < len; m++) {
      p = loaded[m];
      path = sessionContext.deviceData.paths.add(p[0]);
      if (p[1]) {
        l = sessionContext.deviceData.loaded.get(path) | 0;
        sessionContext.deviceData.loaded.set(path, l | p[1]);
      }
    }
    for (o = 0, len1 = parameters.length; o < len1; o++) {
      p = parameters[o];
      path = sessionContext.deviceData.paths.add(p[0]);
      sessionContext.deviceData.timestamps.set(path, p[1], 0);
      if (p[2]) {
        sessionContext.deviceData.attributes.set(path, p[2], 0);
      }
    }
    delete sessionContext.toLoad;
    return callback();
  });
};

generateRpcId = function(sessionContext) {
  return sessionContext.timestamp.toString(16) + ("0" + (sessionContext.cycle.toString(16))).slice(-2) + ("0" + (sessionContext.rpcCount.toString(16))).slice(-2);
};

inform = function(sessionContext, rpcReq, callback) {
  var e, len, len1, len2, m, o, p, params, path, q, ref, ref1, timestamp;
  timestamp = sessionContext.timestamp + sessionContext.iteration + 1;
  params = [];
  params.push([
    ['DeviceID', 'Manufacturer'], timestamp, {
      object: [timestamp, 0],
      writable: [timestamp, 0],
      value: [timestamp, [rpcReq.deviceId.Manufacturer, 'xsd:string']]
    }
  ]);
  params.push([
    ['DeviceID', 'OUI'], timestamp, {
      object: [timestamp, 0],
      writable: [timestamp, 0],
      value: [timestamp, [rpcReq.deviceId.OUI, 'xsd:string']]
    }
  ]);
  params.push([
    ['DeviceID', 'ProductClass'], timestamp, {
      object: [timestamp, 0],
      writable: [timestamp, 0],
      value: [timestamp, [rpcReq.deviceId.ProductClass, 'xsd:string']]
    }
  ]);
  params.push([
    ['DeviceID', 'SerialNumber'], timestamp, {
      object: [timestamp, 0],
      writable: [timestamp, 0],
      value: [timestamp, [rpcReq.deviceId.SerialNumber, 'xsd:string']]
    }
  ]);
  ref = rpcReq.parameterList;
  for (m = 0, len = ref.length; m < len; m++) {
    p = ref[m];
    path = common.parsePath(p[0]);
    params.push([
      path, timestamp, {
        object: [timestamp, 0],
        value: [timestamp, p.slice(1)]
      }
    ]);
  }
  params.push([
    ['Events', 'Inform'], timestamp, {
      object: [timestamp, 0],
      writable: [timestamp, 0],
      value: [timestamp, [sessionContext.timestamp, 'xsd:dateTime']]
    }
  ]);
  ref1 = rpcReq.event;
  for (o = 0, len1 = ref1.length; o < len1; o++) {
    e = ref1[o];
    params.push([
      ['Events', e.replace(' ', '_')], timestamp, {
        object: [timestamp, 0],
        writable: [timestamp, 0],
        value: [timestamp, [sessionContext.timestamp, 'xsd:dateTime']]
      }
    ]);
  }
  loadPath(sessionContext, ['DeviceID', '*']);
  for (q = 0, len2 = params.length; q < len2; q++) {
    p = params[q];
    loadPath(sessionContext, p[0]);
  }
  return loadParameters(sessionContext, function(err) {
    var len3, s, toClear;
    if (err) {
      return callback(err);
    }
    if (sessionContext["new"]) {
      params.push([
        ['DeviceID', 'ID'], timestamp, {
          object: [timestamp, 0],
          writable: [timestamp, 0],
          value: [timestamp, [sessionContext.deviceId, 'xsd:string']]
        }
      ]);
      params.push([
        ['Events', 'Registered'], timestamp, {
          object: [timestamp, 0],
          writable: [timestamp, 0],
          value: [timestamp, [sessionContext.timestamp, 'xsd:dateTime']]
        }
      ]);
    }
    sessionContext.deviceData.timestamps.revision = 1;
    sessionContext.deviceData.attributes.revision = 1;
    toClear = null;
    for (s = 0, len3 = params.length; s < len3; s++) {
      p = params[s];
      if (p[0][0] === 'Events') {
        device.set(sessionContext.deviceData, p[0], p[1], p[2]);
      } else {
        toClear = device.set(sessionContext.deviceData, p[0], p[1], p[2], toClear);
      }
    }
    return clear(sessionContext, toClear, function(err) {
      return callback(err, {
        name: 'InformResponse'
      });
    });
  });
};

transferComplete = function(sessionContext, rpcReq, callback) {
  var commandKey, instance, operation, revision;
  revision = (sessionContext.revisions[sessionContext.revisions.length - 1] || 0) + 1;
  sessionContext.deviceData.timestamps.revision = revision;
  sessionContext.deviceData.attributes.revision = revision;
  commandKey = rpcReq.commandKey;
  operation = sessionContext.operations[commandKey];
  if (operation == null) {
    return callback(null, {
      name: 'TransferCompleteResponse'
    });
  }
  instance = operation.args.instance;
  delete sessionContext.operations[commandKey];
  if (sessionContext.operationsTouched == null) {
    sessionContext.operationsTouched = {};
  }
  sessionContext.operationsTouched[commandKey] = 1;
  if ((rpcReq.faultStruct != null) && rpcReq.faultStruct.faultCode !== '0') {
    return revertDownloadParameters(sessionContext, operation.args.instance, function(err) {
      var fault;
      fault = {
        code: "cwmp." + rpcReq.faultStruct.faultCode,
        message: rpcReq.faultStruct.faultString,
        detail: rpcReq.faultStruct,
        timestamp: operation.timestamp
      };
      return callback(err, {
        name: 'TransferCompleteResponse'
      }, operation, fault);
    });
  }
  loadPath(sessionContext, ['Downloads', instance, '*']);
  return loadParameters(sessionContext, function(err) {
    var p, timestamp, toClear;
    if (err) {
      return callback(err);
    }
    toClear = null;
    timestamp = sessionContext.timestamp + sessionContext.iteration + 1;
    p = sessionContext.deviceData.paths.add(['Downloads', instance, 'LastDownload']);
    toClear = device.set(sessionContext.deviceData, p, timestamp, {
      value: [timestamp, [operation.timestamp, 'xsd:dateTime']]
    }, toClear);
    p = sessionContext.deviceData.paths.add(['Downloads', instance, 'LastFileType']);
    toClear = device.set(sessionContext.deviceData, p, timestamp, {
      value: [timestamp, [operation.args.fileType, 'xsd:string']]
    }, toClear);
    p = sessionContext.deviceData.paths.add(['Downloads', instance, 'LastFileName']);
    toClear = device.set(sessionContext.deviceData, p, timestamp, {
      value: [timestamp, [operation.args.fileName, 'xsd:string']]
    }, toClear);
    p = sessionContext.deviceData.paths.add(['Downloads', instance, 'LastTargetFileName']);
    toClear = device.set(sessionContext.deviceData, p, timestamp, {
      value: [timestamp, [operation.args.targetFileName, 'xsd:string']]
    }, toClear);
    p = sessionContext.deviceData.paths.add(['Downloads', instance, 'StartTime']);
    toClear = device.set(sessionContext.deviceData, p, timestamp, {
      value: [timestamp, [+rpcReq.startTime, 'xsd:dateTime']]
    }, toClear);
    p = sessionContext.deviceData.paths.add(['Downloads', instance, 'CompleteTime']);
    toClear = device.set(sessionContext.deviceData, p, timestamp, {
      value: [timestamp, [+rpcReq.completeTime, 'xsd:dateTime']]
    }, toClear);
    return clear(sessionContext, toClear, function(err) {
      return callback(err, {
        name: 'TransferCompleteResponse'
      }, operation);
    });
  });
};

revertDownloadParameters = function(sessionContext, instance, callback) {
  loadPath(sessionContext, ['Downloads', instance, '*']);
  return loadParameters(sessionContext, function(err) {
    var LastDownload, p, ref, timestamp, toClear;
    if (err) {
      return callback(err);
    }
    timestamp = sessionContext.timestamp + sessionContext.iteration + 1;
    p = sessionContext.deviceData.paths.add(['Downloads', instance, 'LastDownload']);
    LastDownload = sessionContext.deviceData.attributes.get(p);
    p = sessionContext.deviceData.paths.add(['Downloads', instance, 'Download']);
    toClear = device.set(sessionContext.deviceData, p, timestamp, {
      value: [timestamp, [(LastDownload != null ? (ref = LastDownload.value[1]) != null ? ref[0] : void 0 : void 0) || 0, 'xsd:dateTime']]
    }, toClear);
    return clear(sessionContext, toClear, callback);
  });
};

timeoutOperations = function(sessionContext, callback) {
  var DOWNLOAD_TIMEOUT, commandKey, counter, faults, operation, operations, ref, revision;
  revision = (sessionContext.revisions[sessionContext.revisions.length - 1] || 0) + 1;
  sessionContext.deviceData.timestamps.revision = revision;
  sessionContext.deviceData.attributes.revision = revision;
  faults = [];
  operations = [];
  counter = 3;
  ref = sessionContext.operations;
  for (commandKey in ref) {
    operation = ref[commandKey];
    if (operation.name !== 'Download') {
      return callback(new Error("Unknown operation name " + operation.name));
    }
    DOWNLOAD_TIMEOUT = config.get('DOWNLOAD_TIMEOUT', sessionContext.deviceId) * 1000;
    if (sessionContext.timestamp > operation.timestamp + DOWNLOAD_TIMEOUT) {
      delete sessionContext.operations[commandKey];
      if (sessionContext.operationsTouched == null) {
        sessionContext.operationsTouched = {};
      }
      sessionContext.operationsTouched[commandKey] = 1;
      faults.push({
        code: 'timeout',
        message: 'Download operation timed out',
        timestamp: operation.timestamp
      });
      operations.push(operation);
      counter += 2;
      revertDownloadParameters(sessionContext, operation.args.instance, function(err) {
        if (err) {
          if (counter & 1) {
            callback(err);
          }
          return counter = 0;
        }
        if ((counter -= 2) === 1) {
          return callback(null, faults, operations);
        }
      });
    }
  }
  if ((counter -= 2) === 1) {
    return callback(null, faults, operations);
  }
};

addProvisions = function(sessionContext, channel, provisions) {
  var a, c, channels, i, j, len, len1, len2, m, o, p, provision, provisionStr, q, ref, results;
  delete sessionContext.syncState;
  delete sessionContext.rpcRequest;
  sessionContext.declarations = [];
  sessionContext.provisionsRet = [];
  if (sessionContext.revisions[sessionContext.revisions.length - 1] > 0) {
    sessionContext.deviceData.timestamps.collapse(1);
    sessionContext.deviceData.attributes.collapse(1);
    sessionContext.revisions = [0];
    sessionContext.extensionsCache = {};
  }
  if (sessionContext.iteration !== sessionContext.cycle * MAX_ITERATIONS) {
    sessionContext.cycle += 1;
    sessionContext.rpcCount = 0;
    sessionContext.iteration = sessionContext.cycle * MAX_ITERATIONS;
  }
  sessionContext.channels[channel] |= 0;
  results = [];
  for (i = m = 0, len = provisions.length; m < len; i = ++m) {
    provision = provisions[i];
    channels = [channel];
    provisionStr = JSON.stringify(provision);
    ref = sessionContext.provisions;
    for (j = o = 0, len1 = ref.length; o < len1; j = ++o) {
      p = ref[j];
      if (JSON.stringify(p) === provisionStr) {
        sessionContext.provisions.splice(j, 1);
        for (c in sessionContext.channels) {
          if (sessionContext.channels[c] & (1 << j)) {
            channels.push(c);
          }
          a = sessionContext.channels[c] >> (j + 1);
          sessionContext.channels[c] &= (1 << j) - 1;
          sessionContext.channels[c] |= a << j;
        }
      }
    }
    for (q = 0, len2 = channels.length; q < len2; q++) {
      c = channels[q];
      sessionContext.channels[c] |= 1 << sessionContext.provisions.length;
    }
    results.push(sessionContext.provisions.push(provision));
  }
  return results;
};

clearProvisions = function(sessionContext) {
  if (sessionContext.revisions[sessionContext.revisions.length - 1] > 0) {
    sessionContext.deviceData.timestamps.collapse(1);
    sessionContext.deviceData.attributes.collapse(1);
  }
  if (sessionContext.iteration !== sessionContext.cycle * MAX_ITERATIONS) {
    sessionContext.cycle += 1;
    sessionContext.rpcCount = 0;
    sessionContext.iteration = sessionContext.cycle * MAX_ITERATIONS;
  }
  delete sessionContext.syncState;
  delete sessionContext.rpcRequest;
  sessionContext.provisions = [];
  sessionContext.virtualParameters = [];
  sessionContext.channels = {};
  sessionContext.declarations = [];
  sessionContext.provisionsRet = [];
  sessionContext.revisions = [0];
  return sessionContext.extensionsCache = {};
};

runProvisions = function(sessionContext, provisions, startRevision, endRevision, callback) {
  var allClear, allDeclarations, allProvisions, counter, done, fn, j, len, m, provision;
  done = true;
  allDeclarations = [];
  allClear = [];
  counter = 3;
  allProvisions = provisionsCache.get(sessionContext);
  fn = function(j) {
    return sandbox.run(allProvisions[provision[0]].script, {
      args: provision.slice(1)
    }, sessionContext, startRevision, endRevision, function(err, _fault, _clear, _declarations, _done) {
      if (err || _fault) {
        if (counter & 1) {
          callback(err, _fault);
        }
        return counter = 0;
      }
      done && (done = _done);
      allDeclarations[j] = _declarations || [];
      allClear[j] = _clear || [];
      if ((counter -= 2) === 1) {
        allDeclarations = Array.prototype.concat.apply([], allDeclarations);
        allClear = Array.prototype.concat.apply([], allClear);
        return callback(null, null, done, allDeclarations, allClear);
      }
    });
  };
  for (j = m = 0, len = provisions.length; m < len; j = ++m) {
    provision = provisions[j];
    if (allProvisions[provision[0]] == null) {
      allDeclarations[j] = [];
      allClear[j] = [];
      if (defaultProvisions[provision[0]]) {
        done = defaultProvisions[provision[0]](sessionContext, provision, allDeclarations[j], startRevision, endRevision) && done;
      }
      continue;
    }
    counter += 2;
    fn(j);
  }
  if ((counter -= 2) === 1) {
    allDeclarations = Array.prototype.concat.apply([], allDeclarations);
    allClear = Array.prototype.concat.apply([], allClear);
    return callback(null, null, done, allDeclarations, allClear);
  }
};

runVirtualParameters = function(sessionContext, provisions, startRevision, endRevision, callback) {
  var allClear, allDeclarations, allVirtualParameters, counter, done, fn, globals, j, len, m, provision, virtualParameterUpdates;
  done = true;
  virtualParameterUpdates = [];
  allDeclarations = [];
  allClear = [];
  counter = 3;
  allVirtualParameters = virtualParametersCache.get(sessionContext);
  fn = function(provision, j) {
    return sandbox.run(allVirtualParameters[provision[0]].script, globals, sessionContext, startRevision, endRevision, function(err, _fault, _clear, _declarations, _done, _returnValue) {
      var ref, ret;
      if (err || _fault) {
        if (counter & 1) {
          callback(err, _fault);
        }
        return counter = 0;
      }
      done && (done = _done);
      allDeclarations[j] = _declarations || [];
      allClear[j] = _clear || [];
      if (_done) {
        if (!_returnValue) {
          if (counter & 1) {
            callback(null, {
              code: 'script',
              message: 'Invalid virtual parameter return value'
            });
          }
          return counter = 0;
        }
        ret = {};
        if (_returnValue.writable != null) {
          ret.writable = +(!!_returnValue.writable);
        } else if ((provision[1].writable != null) || (provision[2].writable != null)) {
          if (counter & 1) {
            callback(null, {
              code: 'script',
              message: 'Virtual parameter must provide declared attributes'
            });
          }
          return counter = 0;
        }
        if (_returnValue.value != null) {
          if (!Array.isArray(_returnValue.value)) {
            _returnValue.value = [_returnValue.value];
          }
          if (!_returnValue.value[1]) {
            if (typeof _returnValue.value[0] === 'number') {
              _returnValue.value[1] = 'xsd:int';
            } else if (typeof _returnValue.value[0] === 'boolean') {
              _returnValue.value[1] = 'xsd:boolean';
            } else if (_returnValue.value[0] instanceof Date) {
              _returnValue.value[1] = 'xsd:dateTime';
            } else {
              _returnValue.value[1] = 'xsd:string';
            }
          }
          if ((_returnValue.value[0] == null) || ((ref = _returnValue.value[1]) !== 'xsd:int' && ref !== 'xsd:unsignedInt' && ref !== 'xsd:boolean' && ref !== 'xsd:string' && ref !== 'xsd:dateTime' && ref !== 'xsd:base64' && ref !== 'xsd:hexBinary')) {
            if (counter & 1) {
              callback(null, {
                code: 'script',
                message: 'Invalid virtual parameter value attribute'
              });
            }
            return counter = 0;
          }
          ret.value = device.sanitizeParameterValue(_returnValue.value);
        } else if ((provision[1].value != null) || (provision[2].value != null)) {
          if (counter & 1) {
            callback(null, {
              code: 'script',
              message: 'Virtual parameter must provide declared attributes'
            });
          }
          return counter = 0;
        }
        virtualParameterUpdates[j] = ret;
      }
      if ((counter -= 2) === 1) {
        allDeclarations = Array.prototype.concat.apply([], allDeclarations);
        allClear = Array.prototype.concat.apply([], allClear);
        return callback(null, null, (done ? virtualParameterUpdates : null), allDeclarations, allClear);
      }
    });
  };
  for (j = m = 0, len = provisions.length; m < len; j = ++m) {
    provision = provisions[j];
    counter += 2;
    globals = {
      args: provision.slice(1)
    };
    fn(provision, j);
  }
  if ((counter -= 2) === 1) {
    allDeclarations = Array.prototype.concat.apply([], allDeclarations);
    allClear = Array.prototype.concat.apply([], allClear);
    return callback(null, null, (done ? virtualParameterUpdates : null), allDeclarations, allClear);
  }
};

runDeclarations = function(sessionContext, declarations) {
  var ad, aliasDecs, allDeclareAttributeTimestamps, allDeclareAttributeValues, allDeclareTimestamps, allVirtualParameters, attrTrackers, declaration, i, k, keys, len, len1, len2, len3, len4, len5, m, maxInstances, mergeAttributeTimestamps, mergeAttributeValues, minInstances, o, p, parent, parentsUnpacked, path, q, ref, s, t, u, unpacked, w;
  if (sessionContext.syncState == null) {
    sessionContext.syncState = {
      refreshAttributes: {
        exist: new Set(),
        object: new Set(),
        writable: new Set(),
        value: new Set()
      },
      spv: new Map(),
      gpn: new Set(),
      gpnPatterns: new Map(),
      tags: new Map(),
      virtualParameterDeclarations: [],
      instancesToDelete: new Map(),
      instancesToCreate: new Map(),
      downloadsToDelete: new Set(),
      downloadsToCreate: new InstanceSet(),
      downloadsValues: new Map(),
      downloadsDownload: new Map()
    };
  }
  allDeclareTimestamps = new Map();
  allDeclareAttributeTimestamps = new Map();
  allDeclareAttributeValues = new Map();
  allVirtualParameters = virtualParametersCache.get(sessionContext);
  mergeAttributeTimestamps = function(p, attrs) {
    var cur, k, v;
    if (cur = allDeclareAttributeTimestamps.get(p)) {
      cur = Object.assign({}, cur);
      for (k in attrs) {
        v = attrs[k];
        cur[k] = Math.max(v, cur[k] || 0);
      }
      return allDeclareAttributeTimestamps.set(p, cur);
    } else {
      return allDeclareAttributeTimestamps.set(p, attrs);
    }
  };
  mergeAttributeValues = function(p, attrs) {
    var cur;
    if (cur = allDeclareAttributeValues.get(p)) {
      cur = Object.assign({}, cur, attrs);
      return allDeclareAttributeValues.set(p, cur);
    } else {
      return allDeclareAttributeValues.set(p, attrs);
    }
  };
  for (i = m = 0, len = declarations.length; m < len; i = ++m) {
    declaration = declarations[i];
    path = common.addPathMeta(declaration[0]);
    unpacked = null;
    if ((path.alias | path.wildcard) & 1 || path[0] === 'VirtualParameters') {
      sessionContext.deviceData.paths.add(['VirtualParameters']);
      if ((path.alias | path.wildcard) & 2) {
        sessionContext.deviceData.paths.add(['VirtualParameters', '*']);
        for (k in allVirtualParameters) {
          sessionContext.deviceData.paths.add(['VirtualParameters', k]);
        }
      }
    }
    if ((path.alias | path.wildcard) & 1 || path[0] === 'Reboot') {
      sessionContext.deviceData.paths.add(['Reboot']);
    }
    if ((path.alias | path.wildcard) & 1 || path[0] === 'FactoryReset') {
      sessionContext.deviceData.paths.add(['FactoryReset']);
    }
    if (path.alias) {
      aliasDecs = device.getAliasDeclarations(path, declaration[1] || 1);
      for (o = 0, len1 = aliasDecs.length; o < len1; o++) {
        ad = aliasDecs[o];
        p = sessionContext.deviceData.paths.add(ad[0]);
        allDeclareTimestamps.set(p, Math.max(ad[1] || 1, allDeclareTimestamps.get(p) || 0));
        attrTrackers = null;
        if (ad[2]) {
          attrTrackers = Object.keys(ad[2]);
          mergeAttributeTimestamps(p, ad[2]);
        }
        device.track(sessionContext.deviceData, p, 'prerequisite', attrTrackers);
      }
      unpacked = device.unpack(sessionContext.deviceData, path);
      for (q = 0, len2 = unpacked.length; q < len2; q++) {
        u = unpacked[q];
        allDeclareTimestamps.set(u, Math.max(declaration[1] || 1, allDeclareTimestamps.get(u) || 0));
        if (declaration[2]) {
          mergeAttributeTimestamps(u, declaration[2]);
        }
      }
    } else {
      path = sessionContext.deviceData.paths.add(path);
      allDeclareTimestamps.set(path, Math.max(declaration[1] || 1, allDeclareTimestamps.get(path) || 0));
      if (declaration[2]) {
        mergeAttributeTimestamps(path, declaration[2]);
      }
      device.track(sessionContext.deviceData, path, 'prerequisite');
    }
    if (declaration[4]) {
      if (path.alias | path.wildcard) {
        if (unpacked == null) {
          unpacked = device.unpack(sessionContext.deviceData, path);
        }
        for (s = 0, len3 = unpacked.length; s < len3; s++) {
          u = unpacked[s];
          mergeAttributeValues(u, declaration[4]);
        }
      } else {
        mergeAttributeValues(path, declaration[4]);
      }
    }
    if (declaration[3] != null) {
      if (Array.isArray(declaration[3])) {
        minInstances = declaration[3][0];
        maxInstances = declaration[3][1];
      } else {
        minInstances = maxInstances = declaration[3];
      }
      parent = common.addPathMeta(path.slice(0, -1));
      keys = null;
      if (Array.isArray(path[path.length - 1])) {
        keys = {};
        ref = path[path.length - 1];
        for (i = t = 0, len4 = ref.length; t < len4; i = t += 2) {
          p = ref[i];
          keys[p.join('.')] = path[path.length - 1][i + 1];
        }
      } else if (path[path.length - 1] === '*') {
        keys = {};
      }
      if (((path.wildcard | path.alias) & ((1 << (path.length - 1)) - 1)) === 0) {
        parent = sessionContext.deviceData.paths.add(parent);
        if (unpacked == null) {
          unpacked = device.unpack(sessionContext.deviceData, path);
        }
        processInstances(sessionContext, parent, unpacked, keys, minInstances, maxInstances);
      } else {
        parentsUnpacked = device.unpack(sessionContext.deviceData, parent);
        for (w = 0, len5 = parentsUnpacked.length; w < len5; w++) {
          parent = parentsUnpacked[w];
          parent = sessionContext.deviceData.paths.add(parent);
          processInstances(sessionContext, parent, device.unpack(sessionContext.deviceData, common.addPathMeta(parent.concat([path[parent.length]]))), keys, minInstances, maxInstances);
        }
      }
    }
  }
  return processDeclarations(sessionContext, allDeclareTimestamps, allDeclareAttributeTimestamps, allDeclareAttributeValues);
};

rpcRequest = function(sessionContext, _declarations, callback) {
  var ad, allVirtualParameters, base, d, i, inception, index, k, len, len1, len2, m, o, provisions, q, ref, ref1, ref2, ref3, ref4, ret, rev, revision, run, timestamp, toClear, v, vparams, vpd, vpu;
  if (sessionContext.rpcRequest != null) {
    return callback(null, null, generateRpcId(sessionContext), sessionContext.rpcRequest);
  }
  if (sessionContext.virtualParameters.length === 0 && sessionContext.declarations.length === 0 && !(_declarations != null ? _declarations.length : void 0) && sessionContext.provisions.length === 0) {
    return callback();
  }
  if (sessionContext.declarations.length <= sessionContext.virtualParameters.length) {
    inception = sessionContext.declarations.length;
    revision = (sessionContext.revisions[inception] || 0) + 1;
    sessionContext.deviceData.timestamps.revision = revision;
    sessionContext.deviceData.attributes.revision = revision;
    if (inception === 0) {
      run = runProvisions;
      provisions = sessionContext.provisions;
    } else {
      run = runVirtualParameters;
      provisions = sessionContext.virtualParameters[inception - 1];
    }
    return run(sessionContext, provisions, sessionContext.revisions[inception - 1] || 0, sessionContext.revisions[inception], function(err, fault, ret, decs, toClear) {
      var ad, c, d, k, len, len1, len2, m, o, q, ref, ref1, ref2, v;
      if (err) {
        return callback(err);
      }
      if (fault) {
        fault.timestamp = sessionContext.timestamp;
        return callback(null, fault);
      }
      for (m = 0, len = toClear.length; m < len; m++) {
        c = toClear[m];
        if (c[1] > sessionContext.timestamp) {
          c[1] = sessionContext.timestamp;
        }
        ref = c[2];
        for (k in ref) {
          v = ref[k];
          if (v > sessionContext.timestamp) {
            c[2][k] = sessionContext.timestamp;
          }
        }
      }
      sessionContext.declarations.push(decs);
      sessionContext.provisionsRet[inception] = ret;
      for (o = 0, len1 = decs.length; o < len1; o++) {
        d = decs[o];
        if (d[1] > sessionContext.timestamp) {
          d[1] = sessionContext.timestamp;
        }
        ref1 = d[2];
        for (k in ref1) {
          v = ref1[k];
          if (v > sessionContext.timestamp) {
            d[2][k] = sessionContext.timestamp;
          }
        }
        ref2 = device.getAliasDeclarations(d[0], 1);
        for (q = 0, len2 = ref2.length; q < len2; q++) {
          ad = ref2[q];
          loadPath(sessionContext, ad[0]);
        }
      }
      return clear(sessionContext, toClear, function(err) {
        if (err) {
          return callback(err);
        }
        return loadParameters(sessionContext, function(err) {
          if (err) {
            return callback(err);
          }
          return rpcRequest(sessionContext, _declarations, callback);
        });
      });
    });
  }
  if (_declarations != null ? _declarations.length : void 0) {
    delete sessionContext.syncState;
    if ((base = sessionContext.declarations)[0] == null) {
      base[0] = [];
    }
    sessionContext.declarations[0] = sessionContext.declarations[0].concat(_declarations);
    for (m = 0, len = _declarations.length; m < len; m++) {
      d = _declarations[m];
      ref = device.getAliasDeclarations(d[0], 1);
      for (o = 0, len1 = ref.length; o < len1; o++) {
        ad = ref[o];
        loadPath(sessionContext, ad[0]);
      }
    }
    return loadParameters(sessionContext, function(err) {
      if (err) {
        return callback(err);
      }
      return rpcRequest(sessionContext, null, callback);
    });
  }
  if (sessionContext.rpcCount >= 255) {
    return callback(null, {
      code: 'too_many_rpcs',
      message: 'Too many RPC requests',
      timestamp: sessionContext.timestamp
    });
  }
  if (sessionContext.revisions.length >= 8) {
    return callback(null, {
      code: 'deeply_nested_vparams',
      message: 'Virtual parameters are referencing other virtual parameters in a deeply nested manner',
      timestamp: sessionContext.timestamp
    });
  }
  if (sessionContext.cycle >= 255) {
    return callback(null, {
      code: 'too_many_cycles',
      message: 'Too many provision cycles',
      timestamp: sessionContext.timestamp
    });
  }
  if (sessionContext.iteration >= MAX_ITERATIONS * (sessionContext.cycle + 1)) {
    return callback(null, {
      code: 'too_many_commits',
      message: 'Too many commit iterations',
      timestamp: sessionContext.timestamp
    });
  }
  if ((((ref1 = sessionContext.syncState) != null ? (ref2 = ref1.virtualParameterDeclarations) != null ? ref2.length : void 0 : void 0) || 0) < sessionContext.declarations.length) {
    inception = ((ref3 = sessionContext.syncState) != null ? (ref4 = ref3.virtualParameterDeclarations) != null ? ref4.length : void 0 : void 0) || 0;
    if (inception === sessionContext.declarations.length - 1) {
      sessionContext.iteration += 2;
    }
    vpd = runDeclarations(sessionContext, sessionContext.declarations[inception]);
    timestamp = sessionContext.timestamp + sessionContext.iteration;
    toClear = null;
    allVirtualParameters = virtualParametersCache.get(sessionContext);
    vpd = vpd.filter(function(declaration) {
      var k, len2, p, q, ref5, v;
      if (Object.keys(allVirtualParameters).length) {
        if (declaration[0].length === 1) {
          if (!sessionContext.deviceData.attributes.has(declaration[0])) {
            toClear = device.set(sessionContext.deviceData, declaration[0], timestamp, {
              object: [timestamp, 1],
              writable: [timestamp, 0]
            }, toClear);
          }
          return false;
        } else if (declaration[0].length === 2) {
          if (declaration[0][1] === '*') {
            for (k in allVirtualParameters) {
              v = allVirtualParameters[k];
              toClear = device.set(sessionContext.deviceData, ['VirtualParameters', k], timestamp, {
                object: [timestamp, 0]
              }, toClear);
            }
            toClear = device.set(sessionContext.deviceData, declaration[0], timestamp, null, toClear);
            return false;
          } else if (declaration[0][1] in allVirtualParameters) {
            if (!sessionContext.deviceData.attributes.has(declaration[0])) {
              toClear = device.set(sessionContext.deviceData, declaration[0], timestamp, {
                object: [timestamp, 0]
              }, toClear);
            }
            return true;
          }
        }
      }
      ref5 = sessionContext.deviceData.paths.find(declaration[0], false, true);
      for (q = 0, len2 = ref5.length; q < len2; q++) {
        p = ref5[q];
        if (sessionContext.deviceData.attributes.has(p)) {
          if (toClear == null) {
            toClear = [];
          }
          toClear.push([declaration[0], timestamp]);
          break;
        }
      }
      return false;
    });
    return clear(sessionContext, toClear, function(err) {
      if (err) {
        return callback(err);
      }
      sessionContext.syncState.virtualParameterDeclarations[inception] = vpd;
      return rpcRequest(sessionContext, null, callback);
    });
  }
  if (sessionContext.syncState == null) {
    return callback();
  }
  inception = sessionContext.declarations.length - 1;
  provisions = generateGetVirtualParameterProvisions(sessionContext, sessionContext.syncState.virtualParameterDeclarations[inception]);
  if (!provisions) {
    sessionContext.rpcRequest = generateGetRpcRequest(sessionContext);
    if (!sessionContext.rpcRequest) {
      if (sessionContext.deviceData.changes.has('prerequisite')) {
        delete sessionContext.syncState;
        device.clearTrackers(sessionContext.deviceData, 'prerequisite');
        return rpcRequest(sessionContext, null, callback);
      }
      toClear = null;
      timestamp = sessionContext.timestamp + sessionContext.iteration + 1;
      sessionContext.syncState.tags.forEach(function(v, p) {
        var c;
        c = sessionContext.deviceData.attributes.get(p);
        if (v && (c == null)) {
          return toClear = device.set(sessionContext.deviceData, p, timestamp, {
            object: [timestamp, false],
            writable: [timestamp, true],
            value: [timestamp, [true, 'xsd:boolean']]
          }, toClear);
        } else if ((c != null) && !v) {
          return toClear = device.set(sessionContext.deviceData, p, timestamp, null, toClear);
        }
      });
      index = null;
      sessionContext.syncState.downloadsToCreate.forEach(function(instance) {
        var k, len2, p, params, q, ref5, v;
        if (index == null) {
          index = 0;
          ref5 = sessionContext.deviceData.paths.find(['Downloads', '*'], false, true);
          for (q = 0, len2 = ref5.length; q < len2; q++) {
            p = ref5[q];
            if (+p[1] > index && sessionContext.deviceData.attributes.has(p)) {
              index = +p[1];
            }
          }
        }
        ++index;
        toClear = device.set(sessionContext.deviceData, ['Downloads'], timestamp, {
          object: [timestamp, 1],
          writable: [timestamp, 1]
        }, toClear);
        toClear = device.set(sessionContext.deviceData, ['Downloads', "" + index], timestamp, {
          object: [timestamp, 1],
          writable: [timestamp, 1]
        }, toClear);
        params = {
          'FileType': {
            writable: 1,
            value: [instance.FileType || '', 'xsd:string']
          },
          'FileName': {
            writable: 1,
            value: [instance.FileName || '', 'xsd:string']
          },
          'TargetFileName': {
            writable: 1,
            value: [instance.TargetFileName || '', 'xsd:string']
          },
          'Download': {
            writable: 1,
            value: [instance.Download || 0, 'xsd:dateTime']
          },
          'LastFileType': {
            writable: 0,
            value: ['', 'xsd:string']
          },
          'LastFileName': {
            writable: 0,
            value: ['', 'xsd:string']
          },
          'LastTargetFileName': {
            writable: 0,
            value: ['', 'xsd:string']
          },
          'LastDownload': {
            writable: 0,
            value: [0, 'xsd:dateTime']
          },
          'StartTime': {
            writable: 0,
            value: [0, 'xsd:dateTime']
          },
          'CompleteTime': {
            writable: 0,
            value: [0, 'xsd:dateTime']
          }
        };
        for (k in params) {
          v = params[k];
          toClear = device.set(sessionContext.deviceData, ['Downloads', "" + index, k], timestamp, {
            object: [timestamp, 0],
            writable: [timestamp, v.writable],
            value: [timestamp, v.value]
          }, toClear);
        }
        return toClear = device.set(sessionContext.deviceData, ['Downloads', "" + index, '*'], timestamp, null, toClear);
      });
      sessionContext.syncState.downloadsToCreate.clear();
      sessionContext.syncState.downloadsToDelete.forEach(function(instance) {
        toClear = device.set(sessionContext.deviceData, instance, timestamp, null, toClear);
        return sessionContext.syncState.downloadsValues.forEach(function(v, p) {
          if (p[1] === instance[1]) {
            return sessionContext.syncState.downloadsValues["delete"](p);
          }
        });
      });
      sessionContext.syncState.downloadsToDelete.clear();
      sessionContext.syncState.downloadsValues.forEach(function(v, p) {
        var attrs, ref5;
        if (attrs = sessionContext.deviceData.attributes.get(p)) {
          if (((ref5 = attrs.writable) != null ? ref5[1] : void 0) && (attrs.value != null)) {
            v = device.sanitizeParameterValue([v, attrs.value[1][1]]);
            if (v[0] !== attrs.value[1][0]) {
              return toClear = device.set(sessionContext.deviceData, p, timestamp, {
                value: [timestamp, v]
              }, toClear);
            }
          }
        }
      });
      if (toClear || sessionContext.deviceData.changes.has('prerequisite')) {
        return clear(sessionContext, toClear, function(err) {
          if (err) {
            return callback(err);
          }
          return rpcRequest(sessionContext, null, callback);
        });
      }
      provisions = generateSetVirtualParameterProvisions(sessionContext, sessionContext.syncState.virtualParameterDeclarations[inception]);
      if (!provisions) {
        sessionContext.rpcRequest = generateSetRpcRequest(sessionContext);
      }
    }
  }
  if (provisions) {
    sessionContext.virtualParameters.push(provisions);
    sessionContext.revisions.push(sessionContext.revisions[inception]);
    return rpcRequest(sessionContext, null, callback);
  }
  if (sessionContext.rpcRequest) {
    return callback(null, null, generateRpcId(sessionContext), sessionContext.rpcRequest);
  }
  ++sessionContext.revisions[inception];
  sessionContext.declarations.pop();
  sessionContext.syncState.virtualParameterDeclarations.pop();
  ret = sessionContext.provisionsRet.splice(inception)[0];
  if (!ret) {
    return rpcRequest(sessionContext, null, callback);
  }
  sessionContext.revisions.pop();
  rev = sessionContext.revisions[sessionContext.revisions.length - 1] || 0;
  sessionContext.deviceData.timestamps.collapse(rev + 1);
  sessionContext.deviceData.attributes.collapse(rev + 1);
  sessionContext.deviceData.timestamps.revision = rev + 1;
  sessionContext.deviceData.attributes.revision = rev + 1;
  for (k in sessionContext.extensionsCache) {
    if (rev < Number(k.split(':', 1)[0])) {
      delete sessionContext.extensionsCache[k];
    }
  }
  vparams = sessionContext.virtualParameters.pop();
  if (!vparams) {
    return callback();
  }
  timestamp = sessionContext.timestamp + sessionContext.iteration;
  toClear = null;
  for (i = q = 0, len2 = ret.length; q < len2; i = ++q) {
    vpu = ret[i];
    for (k in vpu) {
      v = vpu[k];
      vpu[k] = [timestamp + (vparams[i][2][k] != null ? 1 : 0), v];
    }
    toClear = device.set(sessionContext.deviceData, ['VirtualParameters', vparams[i][0]], timestamp, vpu, toClear);
  }
  return clear(sessionContext, toClear, function(err) {
    if (err) {
      return callback(err);
    }
    return rpcRequest(sessionContext, null, callback);
  });
};

generateGetRpcRequest = function(sessionContext) {
  var GPN_NEXT_LEVEL, GPV_BATCH_SIZE, attrs, est, f, found, iter, len, len1, len2, len3, m, nextLevel, o, p, parameterNames, path, paths, patterns, q, ref, ref1, ref2, ref3, s, syncState, v;
  if ((syncState = sessionContext.syncState) == null) {
    return;
  }
  iter = syncState.refreshAttributes.exist.values();
  while ((path = iter.next().value)) {
    found = false;
    ref = sessionContext.deviceData.paths.find(path, false, true, 99);
    for (m = 0, len = ref.length; m < len; m++) {
      p = ref[m];
      if (syncState.refreshAttributes.value.has(p) || syncState.refreshAttributes.object.has(p) || syncState.refreshAttributes.writable.has(p) || syncState.gpn.has(p)) {
        found = true;
        break;
      }
    }
    if (!found) {
      p = sessionContext.deviceData.paths.add(path.slice(0, -1));
      syncState.gpn.add(p);
      f = 1 << p.length;
      syncState.gpnPatterns.set(p, f | syncState.gpnPatterns.get(p));
    }
  }
  syncState.refreshAttributes.exist.clear();
  iter = syncState.refreshAttributes.object.values();
  while ((path = iter.next().value)) {
    found = false;
    ref1 = sessionContext.deviceData.paths.find(path, false, true, 99);
    for (o = 0, len1 = ref1.length; o < len1; o++) {
      p = ref1[o];
      if (syncState.refreshAttributes.value.has(p) || (p.length > path.length && (syncState.refreshAttributes.object.has(p) || syncState.refreshAttributes.writable.has(p)))) {
        found = true;
        break;
      }
    }
    if (!found) {
      p = sessionContext.deviceData.paths.add(path.slice(0, -1));
      syncState.gpn.add(p);
      f = 1 << p.length;
      syncState.gpnPatterns.set(p, f | syncState.gpnPatterns.get(p));
    }
  }
  syncState.refreshAttributes.object.clear();
  iter = syncState.refreshAttributes.writable.values();
  while ((path = iter.next().value)) {
    p = sessionContext.deviceData.paths.add(path.slice(0, -1));
    syncState.gpn.add(p);
    f = 1 << p.length;
    syncState.gpnPatterns.set(p, f | syncState.gpnPatterns.get(p));
  }
  syncState.refreshAttributes.writable.clear();
  if (syncState.gpn.size) {
    GPN_NEXT_LEVEL = config.get('GPN_NEXT_LEVEL', sessionContext.deviceId);
    paths = Array.from(syncState.gpn.keys()).sort(function(a, b) {
      return b.length - a.length;
    });
    path = paths.pop();
    while (path && path.length && !sessionContext.deviceData.attributes.has(path)) {
      syncState.gpn["delete"](path);
      path = paths.pop();
    }
    if (path) {
      if (path.length >= GPN_NEXT_LEVEL) {
        patterns = [[path, 0]];
        ref2 = sessionContext.deviceData.paths.find(path, true, false, 99);
        for (q = 0, len2 = ref2.length; q < len2; q++) {
          p = ref2[q];
          if (v = syncState.gpnPatterns.get(p)) {
            patterns.push([p, (v >> path.length) << path.length]);
          }
        }
        est = gpnHeuristic.estimateGpnCount(patterns);
      } else {
        est = 0;
      }
      if (est < Math.pow(2, Math.max(0, 8 - path.length))) {
        nextLevel = true;
        syncState.gpn["delete"](path);
      } else {
        nextLevel = false;
        ref3 = sessionContext.deviceData.paths.find(path, false, true, 99);
        for (s = 0, len3 = ref3.length; s < len3; s++) {
          p = ref3[s];
          syncState.gpn["delete"](p);
        }
      }
      return {
        name: 'GetParameterNames',
        parameterPath: path.concat('').join('.'),
        nextLevel: nextLevel
      };
    }
  }
  if (syncState.refreshAttributes.value.size) {
    GPV_BATCH_SIZE = config.get('GPV_BATCH_SIZE', sessionContext.deviceId);
    parameterNames = [];
    iter = syncState.refreshAttributes.value.values();
    while ((path = iter.next().value) && parameterNames.length < GPV_BATCH_SIZE) {
      syncState.refreshAttributes.value["delete"](path);
      attrs = sessionContext.deviceData.attributes.get(path);
      if (attrs && attrs.object && attrs.object[1] === 0) {
        parameterNames.push(path);
      }
    }
    if (parameterNames.length) {
      return {
        name: 'GetParameterValues',
        parameterNames: (function() {
          var len4, results, t;
          results = [];
          for (t = 0, len4 = parameterNames.length; t < len4; t++) {
            p = parameterNames[t];
            results.push(p.join('.'));
          }
          return results;
        })()
      };
    }
  }
  return null;
};

generateSetRpcRequest = function(sessionContext) {
  var BOOLEAN_LITERAL, DATETIME_MILLISECONDS, GPV_BATCH_SIZE, deviceData, fileNamePath, fileTypePath, instance, instances, iter, p, pair, parameterValues, ref, ref1, ref10, ref11, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, syncState, targetFileNamePath;
  if ((syncState = sessionContext.syncState) == null) {
    return;
  }
  deviceData = sessionContext.deviceData;
  iter = syncState.instancesToDelete.values();
  while (instances = iter.next().value) {
    if ((instance = instances.values().next().value) && sessionContext.deviceData.attributes.has(instance)) {
      return {
        name: 'DeleteObject',
        objectName: instance.concat('').join('.')
      };
    }
  }
  iter = syncState.instancesToCreate.entries();
  while (pair = iter.next().value) {
    if (sessionContext.deviceData.attributes.has(pair[0]) && (instance = pair[1].values().next().value)) {
      pair[1]["delete"](instance);
      return {
        name: 'AddObject',
        objectName: pair[0].concat('').join('.'),
        instanceValues: instance,
        next: 'getInstanceKeys'
      };
    }
  }
  GPV_BATCH_SIZE = config.get('GPV_BATCH_SIZE', sessionContext.deviceId);
  DATETIME_MILLISECONDS = config.get('DATETIME_MILLISECONDS', sessionContext.deviceId);
  BOOLEAN_LITERAL = config.get('BOOLEAN_LITERAL', sessionContext.deviceId);
  parameterValues = [];
  syncState.spv.forEach(function(v, k) {
    var attrs, curVal, ref, ref1, val;
    if (parameterValues.length >= GPV_BATCH_SIZE) {
      return;
    }
    syncState.spv["delete"](k);
    attrs = sessionContext.deviceData.attributes.get(k);
    if (((curVal = (ref = attrs.value) != null ? ref[1] : void 0) != null) && ((ref1 = attrs.writable) != null ? ref1[1] : void 0)) {
      val = v.slice();
      if (val[1] == null) {
        val[1] = curVal[1];
      }
      device.sanitizeParameterValue(val);
      if (val[1] === 'xsd:dateTime' && !DATETIME_MILLISECONDS && typeof val[0] === 'number') {
        val[0] -= val[0] % 1000;
      }
      if (val[0] !== curVal[0] || val[1] !== curVal[1]) {
        return parameterValues.push([k, val[0], val[1]]);
      }
    }
  });
  if (parameterValues.length) {
    return {
      name: 'SetParameterValues',
      parameterList: (function() {
        var len, m, results;
        results = [];
        for (m = 0, len = parameterValues.length; m < len; m++) {
          p = parameterValues[m];
          results.push([p[0].join('.'), p[1], p[2]]);
        }
        return results;
      })(),
      DATETIME_MILLISECONDS: DATETIME_MILLISECONDS,
      BOOLEAN_LITERAL: BOOLEAN_LITERAL
    };
  }
  iter = syncState.downloadsDownload.entries();
  while (pair = iter.next().value) {
    if (!(pair[1] <= ((ref = deviceData.attributes.get(pair[0])) != null ? (ref1 = ref.value) != null ? ref1[1][0] : void 0 : void 0))) {
      fileTypePath = deviceData.paths.get(pair[0].slice(0, -1).concat('FileType'));
      fileNamePath = deviceData.paths.get(pair[0].slice(0, -1).concat('FileName'));
      targetFileNamePath = deviceData.paths.get(pair[0].slice(0, -1).concat('TargetFileName'));
      return {
        name: 'Download',
        commandKey: generateRpcId(sessionContext),
        instance: pair[0][1],
        fileType: (ref2 = deviceData.attributes.get(fileTypePath)) != null ? (ref3 = ref2.value) != null ? ref3[1][0] : void 0 : void 0,
        fileName: (ref4 = deviceData.attributes.get(fileNamePath)) != null ? (ref5 = ref4.value) != null ? ref5[1][0] : void 0 : void 0,
        targetFileName: (ref6 = deviceData.attributes.get(targetFileNamePath)) != null ? (ref7 = ref6.value) != null ? ref7[1][0] : void 0 : void 0
      };
    }
  }
  if (syncState.reboot != null) {
    p = sessionContext.deviceData.paths.get(['Reboot']);
    if (!((p != null) && ((ref8 = sessionContext.deviceData.attributes.get(p)) != null ? (ref9 = ref8.value) != null ? ref9[1][0] : void 0 : void 0) >= syncState.reboot)) {
      delete syncState.reboot;
      return {
        name: 'Reboot'
      };
    }
  }
  if (syncState.factoryReset != null) {
    p = sessionContext.deviceData.paths.get(['FactoryReset']);
    if (!((p != null) && ((ref10 = sessionContext.deviceData.attributes.get(p)) != null ? (ref11 = ref10.value) != null ? ref11[1][0] : void 0 : void 0) >= syncState.factoryReset)) {
      delete syncState.factoryReset;
      return {
        name: 'FactoryReset'
      };
    }
  }
  return null;
};

generateGetVirtualParameterProvisions = function(sessionContext, virtualParameterDeclarations) {
  var attrs, currentTimestamps, currentValues, dec, declaration, k, len, m, provisions, ref, v;
  provisions = null;
  for (m = 0, len = virtualParameterDeclarations.length; m < len; m++) {
    declaration = virtualParameterDeclarations[m];
    if (declaration[1]) {
      currentTimestamps = {};
      currentValues = {};
      dec = {};
      attrs = sessionContext.deviceData.attributes.get(declaration[0]) || {};
      ref = declaration[1];
      for (k in ref) {
        v = ref[k];
        if (k !== 'value' && k !== 'writable') {
          continue;
        }
        if (!attrs[k] || v > attrs[k][0]) {
          dec[k] = v;
        }
      }
      for (k in attrs) {
        v = attrs[k];
        currentTimestamps[k] = v[0];
        currentValues[k] = v[1];
      }
      if ((Object.keys(dec).length)) {
        if (provisions == null) {
          provisions = [];
        }
        provisions.push([declaration[0][1], dec, {}, currentTimestamps, currentValues]);
      }
    }
  }
  return provisions;
};

generateSetVirtualParameterProvisions = function(sessionContext, virtualParameterDeclarations) {
  var attrs, curVal, currentTimestamps, currentValues, declaration, k, len, m, provisions, ref, ref1, ref2, v, val;
  provisions = null;
  for (m = 0, len = virtualParameterDeclarations.length; m < len; m++) {
    declaration = virtualParameterDeclarations[m];
    if (((ref = declaration[2]) != null ? ref.value : void 0) != null) {
      attrs = sessionContext.deviceData.attributes.get(declaration[0]);
      if (((curVal = (ref1 = attrs.value) != null ? ref1[1] : void 0) != null) && ((ref2 = attrs.writable) != null ? ref2[1] : void 0)) {
        val = declaration[2].value.slice();
        if (val[1] == null) {
          val[1] = curVal[1];
        }
        device.sanitizeParameterValue(val);
        if (val[0] !== curVal[0] || val[1] !== curVal[1]) {
          if (provisions == null) {
            provisions = [];
          }
          currentTimestamps = {};
          currentValues = {};
          for (k in attrs) {
            v = attrs[k];
            currentTimestamps[k] = v[0];
            currentValues[k] = v[1];
          }
          provisions.push([
            declaration[0][1], {}, {
              value: val
            }, currentTimestamps, currentValues
          ]);
        }
      }
    }
  }
  return provisions;
};

processDeclarations = function(sessionContext, allDeclareTimestamps, allDeclareAttributeTimestamps, allDeclareAttributeValues) {
  var deviceData, func, paths, root, syncState, toClear, virtualParameterDeclarations;
  deviceData = sessionContext.deviceData;
  syncState = sessionContext.syncState;
  root = sessionContext.deviceData.paths.add([]);
  paths = sessionContext.deviceData.paths.find([], false, true, 99);
  paths.sort(function(a, b) {
    if (a.wildcard === b.wildcard) {
      return a.length - b.length;
    }
    return a.wildcard - b.wildcard;
  });
  toClear = null;
  virtualParameterDeclarations = [];
  func = function(leafParam, leafIsObject, leafTimestamp, paths) {
    var attrName, attrs, child, children, currentAttributes, currentPath, currentTimestamp, d, declareAttributeTimestamps, declareAttributeValues, declareTimestamp, f, fragment, k, len, m, p, path, ref, ref1, ref2, ref3, ref4, ref5, results, v;
    currentPath = paths[0];
    children = {};
    declareTimestamp = 0;
    declareAttributeTimestamps = null;
    declareAttributeValues = null;
    currentTimestamp = 0;
    currentAttributes = null;
    if (currentPath.wildcard === 0) {
      currentAttributes = deviceData.attributes.get(currentPath);
    }
    for (m = 0, len = paths.length; m < len; m++) {
      path = paths[m];
      if (path.length > currentPath.length) {
        fragment = path[currentPath.length];
        if (!children[fragment]) {
          children[fragment] = [];
          if (path.length > currentPath.length + 1) {
            p = common.addPathMeta(path.slice(0, currentPath.length + 1));
            children[fragment].push(p);
          }
        }
        children[fragment].push(path);
        continue;
      }
      currentTimestamp = Math.max(currentTimestamp, (ref = deviceData.timestamps.get(path)) != null ? ref : 0);
      declareTimestamp = Math.max(declareTimestamp, (ref1 = allDeclareTimestamps.get(path)) != null ? ref1 : 0);
      if (currentPath.wildcard === 0) {
        if (attrs = allDeclareAttributeTimestamps.get(path)) {
          if (declareAttributeTimestamps) {
            declareAttributeTimestamps = Object.assign({}, declareAttributeTimestamps);
            for (k in attrs) {
              v = attrs[k];
              declareAttributeTimestamps[k] = Math.max(v, declareAttributeTimestamps[k] || 0);
            }
          } else {
            declareAttributeTimestamps = attrs;
          }
        }
        if (attrs = allDeclareAttributeValues.get(path)) {
          declareAttributeValues = attrs;
        }
      }
    }
    if (currentAttributes) {
      leafParam = currentPath;
      leafIsObject = (ref2 = currentAttributes.object) != null ? ref2[1] : void 0;
      if (leafIsObject === 0) {
        leafTimestamp = Math.max(leafTimestamp, currentAttributes.object[0]);
      }
    } else {
      leafTimestamp = Math.max(leafTimestamp, currentTimestamp);
    }
    switch ((currentPath[0] !== '*' ? currentPath[0] : leafParam[0])) {
      case 'Reboot':
        if (currentPath.length === 1) {
          if ((declareAttributeValues != null ? declareAttributeValues.value : void 0) != null) {
            syncState.reboot = +(new Date(declareAttributeValues.value[0]));
          }
        }
        break;
      case 'FactoryReset':
        if (currentPath.length === 1) {
          if ((declareAttributeValues != null ? declareAttributeValues.value : void 0) != null) {
            syncState.factoryReset = +(new Date(declareAttributeValues.value[0]));
          }
        }
        break;
      case 'Tags':
        if (currentPath.length === 2 && currentPath.wildcard === 0 && ((declareAttributeValues != null ? declareAttributeValues.value : void 0) != null)) {
          syncState.tags.set(currentPath, device.sanitizeParameterValue([declareAttributeValues.value[0], 'xsd:boolean'])[0]);
        }
        break;
      case 'Events':
      case 'DeviceID':
        break;
      case 'Downloads':
        if (currentPath.length === 3 && currentPath.wildcard === 0 && ((declareAttributeValues != null ? declareAttributeValues.value : void 0) != null)) {
          if (currentPath[2] === 'Download') {
            syncState.downloadsDownload.set(currentPath, declareAttributeValues.value[0]);
          } else {
            syncState.downloadsValues.set(currentPath, declareAttributeValues.value[0]);
          }
        }
        break;
      case 'VirtualParameters':
        if (currentPath.length <= 2) {
          d = null;
          if (!(declareTimestamp <= currentTimestamp)) {
            d = [currentPath];
          }
          if (currentPath.wildcard === 0) {
            if (declareAttributeTimestamps) {
              for (attrName in declareAttributeTimestamps) {
                if (!(declareAttributeTimestamps[attrName] <= (currentAttributes != null ? (ref3 = currentAttributes[attrName]) != null ? ref3[0] : void 0 : void 0))) {
                  if (d == null) {
                    d = [currentPath];
                  }
                  if (d[1] == null) {
                    d[1] = {};
                  }
                  d[1][attrName] = declareAttributeTimestamps[attrName];
                }
              }
            }
            if (declareAttributeValues) {
              if (d == null) {
                d = [currentPath];
              }
              d[2] = declareAttributeValues;
            }
          }
          if (d) {
            virtualParameterDeclarations.push(d);
          }
        }
        break;
      default:
        if (declareTimestamp > currentTimestamp && declareTimestamp > leafTimestamp) {
          if (currentPath === leafParam) {
            syncState.refreshAttributes.exist.add(leafParam);
          } else if (leafIsObject) {
            syncState.gpn.add(leafParam);
            if (leafTimestamp > 0) {
              f = 1 << leafParam.length;
              syncState.gpnPatterns.set(leafParam, f | syncState.gpnPatterns.get(leafParam));
            } else {
              f = ((1 << currentPath.length) - 1) ^ ((1 << leafParam.length) - 1);
              syncState.gpnPatterns.set(currentPath, f | syncState.gpnPatterns.get(currentPath));
            }
          } else {
            syncState.refreshAttributes.object.add(leafParam);
            if (leafIsObject == null) {
              f = ((1 << syncState.gpnPatterns.length) - 1) ^ ((1 << leafParam.length) - 1);
              syncState.gpnPatterns.set(currentPath, f | syncState.gpnPatterns.get(currentPath));
            }
          }
        }
        if (currentAttributes) {
          for (attrName in declareAttributeTimestamps) {
            if (!(declareAttributeTimestamps[attrName] <= ((ref4 = currentAttributes[attrName]) != null ? ref4[0] : void 0))) {
              if (attrName === 'value') {
                if (((ref5 = currentAttributes.object) != null ? ref5[1] : void 0) == null) {
                  syncState.refreshAttributes.object.add(currentPath);
                } else if (currentAttributes.object[1] === 0) {
                  syncState.refreshAttributes.value.add(currentPath);
                }
              } else {
                syncState.refreshAttributes[attrName].add(currentPath);
              }
            }
          }
          if ((declareAttributeValues != null ? declareAttributeValues.value : void 0) != null) {
            syncState.spv.set(currentPath, declareAttributeValues.value);
          }
        }
    }
    results = [];
    for (child in children) {
      if (((currentPath.wildcard ^ children[child][0].wildcard) & ((1 << currentPath.length) - 1)) >> leafParam.length === 0) {
        if (child !== '*' && (children['*'] != null)) {
          children[child] = children[child].concat(children['*']);
        }
        results.push(func(leafParam, leafIsObject, leafTimestamp, children[child]));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };
  if (allDeclareTimestamps.size || allDeclareAttributeTimestamps.size || allDeclareAttributeValues.size) {
    func(root, 1, 0, paths);
  }
  return virtualParameterDeclarations;
};

loadPath = function(sessionContext, path, depth) {
  var d, i, len, m, o, ref, ref1, sup, trimWildcard, v;
  depth = depth || (1 << path.length) - 1;
  if (sessionContext["new"] || !depth) {
    return true;
  }
  if (sessionContext.toLoad == null) {
    sessionContext.toLoad = new Map();
  }
  trimWildcard = path.length;
  while (trimWildcard && path[trimWildcard - 1] === '*') {
    --trimWildcard;
  }
  if (trimWildcard < path.length) {
    path = path.slice(0, trimWildcard);
  }
  for (i = m = 0, ref = path.length; m <= ref; i = m += 1) {
    d = i === path.length ? 99 : i;
    ref1 = sessionContext.deviceData.paths.find(path.slice(0, i), true, false, d);
    for (o = 0, len = ref1.length; o < len; o++) {
      sup = ref1[o];
      v = sessionContext.deviceData.loaded.get(sup) | sessionContext.toLoad.get(sup);
      if (sup.length > i) {
        v &= (1 << i) - 1;
      }
      depth &= depth ^ v;
      if (depth === 0) {
        return true;
      }
    }
  }
  path = sessionContext.deviceData.paths.add(path);
  depth |= sessionContext.toLoad.get(path);
  sessionContext.toLoad.set(path, depth);
  return false;
};

processInstances = function(sessionContext, parent, parameters, keys, minInstances, maxInstances) {
  var counter, inst, instancesToCreate, instancesToDelete, len, len1, len2, m, o, p, q, subset, superset;
  if (parent[0] === 'Downloads') {
    if (parent.length !== 1) {
      return;
    }
    instancesToDelete = sessionContext.syncState.downloadsToDelete;
    instancesToCreate = sessionContext.syncState.downloadsToCreate;
  } else {
    instancesToDelete = sessionContext.syncState.instancesToDelete.get(parent);
    if (instancesToDelete == null) {
      instancesToDelete = new Set();
      sessionContext.syncState.instancesToDelete.set(parent, instancesToDelete);
    }
    instancesToCreate = sessionContext.syncState.instancesToCreate.get(parent);
    if (instancesToCreate == null) {
      instancesToCreate = new InstanceSet();
      sessionContext.syncState.instancesToCreate.set(parent, instancesToCreate);
    }
  }
  counter = 0;
  for (m = 0, len = parameters.length; m < len; m++) {
    p = parameters[m];
    ++counter;
    if (counter > maxInstances) {
      instancesToDelete.add(p);
    } else if (counter <= minInstances) {
      instancesToDelete["delete"](p);
    }
  }
  if (!keys) {
    return;
  }
  superset = instancesToCreate.superset(keys);
  for (o = 0, len1 = superset.length; o < len1; o++) {
    inst = superset[o];
    ++counter;
    if (counter > maxInstances) {
      instancesToCreate["delete"](inst);
    }
  }
  subset = instancesToCreate.subset(keys);
  for (q = 0, len2 = subset.length; q < len2; q++) {
    inst = subset[q];
    ++counter;
    if (counter <= minInstances) {
      instancesToCreate["delete"](inst);
      instancesToCreate.add(JSON.parse(JSON.stringify(keys)));
    }
  }
  while (counter < minInstances) {
    ++counter;
    instancesToCreate.add(JSON.parse(JSON.stringify(keys)));
  }
};

clear = function(sessionContext, toClear, callback) {
  var MAX_DEPTH;
  if (!(toClear != null ? toClear.length : void 0)) {
    return callback();
  }
  MAX_DEPTH = config.get('MAX_DEPTH', sessionContext.deviceId);
  toClear.forEach(function(c) {
    var p;
    if (c[1]) {
      p = c[0].slice(0, -1);
      return loadPath(sessionContext, p, ((1 << p.length) - 1) ^ ((1 << MAX_DEPTH) - 1));
    } else if (c[2] && c[2].object) {
      return loadPath(sessionContext, c[0], (((1 << c[0].length) - 1) >> 1) ^ ((1 << MAX_DEPTH) - 1));
    } else {
      return loadPath(sessionContext, c[0], (1 << c[0].length) >> 1);
    }
  });
  return loadParameters(sessionContext, function(err) {
    if (err) {
      return callback(err);
    }
    toClear.forEach(function(c) {
      return device.clear(sessionContext.deviceData, c[0], c[1], c[2], c[3]);
    });
    return callback();
  });
};

rpcResponse = function(sessionContext, id, rpcRes, callback) {
  var channel, i, instanceNumber, instanceValues, k, len, len1, len2, len3, m, missing, n, o, operation, p, parameterList, parameterNames, params, path, q, ref, ref1, ref2, ref3, ref4, revision, root, rpcReq, s, timestamp, toClear, v;
  if (id !== generateRpcId(sessionContext)) {
    return callback(new Error('Request ID not recognized'));
  }
  ++sessionContext.rpcCount;
  rpcReq = sessionContext.rpcRequest;
  if (rpcReq.next == null) {
    sessionContext.rpcRequest = null;
  } else if (rpcReq.next === 'getInstanceKeys') {
    instanceNumber = rpcRes.instanceNumber;
    parameterNames = [];
    instanceValues = {};
    ref = rpcReq.instanceValues;
    for (k in ref) {
      v = ref[k];
      n = "" + rpcReq.objectName + rpcRes.instanceNumber + "." + k;
      parameterNames.push(n);
      instanceValues[n] = v;
    }
    if (parameterNames.length === 0) {
      sessionContext.rpcRequest = null;
    } else {
      sessionContext.rpcRequest = {
        name: 'GetParameterValues',
        parameterNames: parameterNames,
        next: 'setInstanceKeys',
        instanceValues: instanceValues
      };
    }
  } else if (rpcReq.next === 'setInstanceKeys') {
    parameterList = [];
    ref1 = rpcRes.parameterList;
    for (m = 0, len = ref1.length; m < len; m++) {
      p = ref1[m];
      if (p[1] !== rpcReq.instanceValues[p[0]]) {
        parameterList.push([p[0]].concat(device.sanitizeParameterValue([rpcReq.instanceValues[p[0]], p[2]])));
      }
    }
    if (!parameterList.length) {
      sessionContext.rpcRequest = null;
    } else {
      sessionContext.rpcRequest = {
        name: 'SetParameterValues',
        parameterList: parameterList
      };
    }
  }
  timestamp = sessionContext.timestamp + sessionContext.iteration;
  revision = (sessionContext.revisions[sessionContext.revisions.length - 1] || 0) + 1;
  sessionContext.deviceData.timestamps.revision = revision;
  sessionContext.deviceData.attributes.revision = revision;
  toClear = null;
  switch (rpcRes.name) {
    case 'GetParameterValuesResponse':
      if (rpcReq.name !== 'GetParameterValues') {
        return callback(new Error('Response name does not match request name'));
      }
      ref2 = rpcRes.parameterList;
      for (o = 0, len1 = ref2.length; o < len1; o++) {
        p = ref2[o];
        toClear = device.set(sessionContext.deviceData, common.parsePath(p[0]), timestamp, {
          object: [timestamp, 0],
          value: [timestamp, p.slice(1)]
        }, toClear);
      }
      break;
    case 'GetParameterNamesResponse':
      if (rpcReq.name !== 'GetParameterNames') {
        return callback(new Error('Response name does not match request name'));
      }
      if (rpcReq.parameterPath.endsWith('.')) {
        root = common.parsePath(rpcReq.parameterPath.slice(0, -1));
      } else {
        root = common.parsePath(rpcReq.parameterPath);
      }
      params = [];
      params.push([root.concat('*'), timestamp]);
      missing = {};
      ref3 = rpcRes.parameterList;
      for (q = 0, len2 = ref3.length; q < len2; q++) {
        p = ref3[q];
        i = p[0].length - 1;
        while ((i = p[0].lastIndexOf('.', i - 1)) > rpcReq.parameterPath.length) {
          missing[p[0].slice(0, i)] |= 0;
        }
        if (p[0].endsWith('.')) {
          missing[p[0].slice(0, -1)] |= 1;
          path = common.parsePath(p[0].slice(0, -1));
          if (!rpcReq.nextLevel) {
            params.push([path.concat('*'), timestamp]);
          }
          params.push([
            path, timestamp, {
              object: [timestamp, 1],
              writable: [timestamp, p[1] ? 1 : 0]
            }
          ]);
        } else {
          missing[p[0]] |= 1;
          params.push([
            common.parsePath(p[0]), timestamp, {
              object: [timestamp, 0],
              writable: [timestamp, p[1] ? 1 : 0]
            }
          ]);
        }
      }
      for (k in missing) {
        v = missing[k];
        if (!(v === 0)) {
          continue;
        }
        path = common.parsePath(k);
        params.push([
          path, timestamp, {
            object: [timestamp, 1],
            writable: [timestamp, 0]
          }
        ]);
        params.push([path.concat('*'), timestamp]);
      }
      params.sort(function(a, b) {
        var al, bl;
        al = a[0].length;
        bl = b[0].length;
        if (b[0][bl - 1] === '*') {
          bl *= -1;
        }
        if (a[0][al - 1] === '*') {
          al *= -1;
        }
        return bl - al;
      });
      if (rpcReq.nextLevel) {
        loadPath(sessionContext, root, (1 << (root.length + 1)) - 1);
      } else {
        loadPath(sessionContext, root, (1 << config.get('MAX_DEPTH', sessionContext.deviceId)) - 1);
      }
      loadParameters(sessionContext, function(err) {
        var len3, len4, ref4, s, t;
        if (err) {
          return callback(err);
        }
        if (root.length === 0) {
          ref4 = ['DeviceID', 'Events', 'Tags', 'Reboot', 'FactoryReset', 'VirtualParameters', 'Downloads'];
          for (s = 0, len3 = ref4.length; s < len3; s++) {
            n = ref4[s];
            if (p = sessionContext.deviceData.paths.get([n])) {
              if (sessionContext.deviceData.attributes.has(p)) {
                sessionContext.deviceData.timestamps.set(p, timestamp);
              }
            }
          }
        }
        for (t = 0, len4 = params.length; t < len4; t++) {
          p = params[t];
          toClear = device.set(sessionContext.deviceData, p[0], p[1], p[2], toClear);
        }
        return clear(sessionContext, toClear, callback);
      });
      return;
    case 'SetParameterValuesResponse':
      if (rpcReq.name !== 'SetParameterValues') {
        return callback(new Error('Response name does not match request name'));
      }
      ref4 = rpcReq.parameterList;
      for (s = 0, len3 = ref4.length; s < len3; s++) {
        p = ref4[s];
        toClear = device.set(sessionContext.deviceData, common.parsePath(p[0]), timestamp + 1, {
          object: [timestamp + 1, 0],
          writable: [timestamp + 1, 1],
          value: [timestamp + 1, p.slice(1)]
        }, toClear);
      }
      break;
    case 'AddObjectResponse':
      toClear = device.set(sessionContext.deviceData, common.parsePath(rpcReq.objectName + rpcRes.instanceNumber), timestamp + 1, {
        object: [timestamp + 1, 1]
      }, toClear);
      break;
    case 'DeleteObjectResponse':
      toClear = device.set(sessionContext.deviceData, common.parsePath(rpcReq.objectName.slice(0, -1)), timestamp + 1, null, toClear);
      break;
    case 'RebootResponse':
      toClear = device.set(sessionContext.deviceData, common.parsePath('Reboot'), timestamp + 1, {
        value: [timestamp + 1, [sessionContext.timestamp, 'xsd:dateTime']]
      }, toClear);
      break;
    case 'FactoryResetResponse':
      toClear = device.set(sessionContext.deviceData, common.parsePath('FactoryReset'), timestamp + 1, {
        value: [timestamp + 1, [sessionContext.timestamp, 'xsd:dateTime']]
      }, toClear);
      break;
    case 'DownloadResponse':
      toClear = device.set(sessionContext.deviceData, ['Downloads', rpcReq.instance, 'Download'], timestamp + 1, {
        value: [timestamp + 1, [sessionContext.timestamp, 'xsd:dateTime']]
      }, toClear);
      if (rpcRes.status === 0) {
        toClear = device.set(sessionContext.deviceData, ['Downloads', rpcReq.instance, 'LastDownload'], timestamp + 1, {
          value: [timestamp + 1, [sessionContext.timestamp, 'xsd:dateTime']]
        }, toClear);
        toClear = device.set(sessionContext.deviceData, ['Downloads', rpcReq.instance, 'LastFileType'], timestamp + 1, {
          value: [timestamp + 1, [rpcReq.fileType, 'xsd:string']]
        }, toClear);
        toClear = device.set(sessionContext.deviceData, ['Downloads', rpcReq.instance, 'LastFileName'], timestamp + 1, {
          value: [timestamp + 1, [rpcReq.fileType, 'xsd:string']]
        }, toClear);
        toClear = device.set(sessionContext.deviceData, ['Downloads', rpcReq.instance, 'LastTargetFileName'], timestamp + 1, {
          value: [timestamp + 1, [rpcReq.fileType, 'xsd:string']]
        }, toClear);
        toClear = device.set(sessionContext.deviceData, ['Downloads', rpcReq.instance, 'StartTime'], timestamp + 1, {
          value: [timestamp + 1, [+rpcRes.startTime, 'xsd:dateTime']]
        }, toClear);
        toClear = device.set(sessionContext.deviceData, ['Downloads', rpcReq.instance, 'CompleteTime'], timestamp + 1, {
          value: [timestamp + 1, [+rpcRes.completeTime, 'xsd:dateTime']]
        }, toClear);
      } else {
        operation = {
          name: 'Download',
          timestamp: sessionContext.timestamp,
          provisions: sessionContext.provisions,
          channels: sessionContext.channels,
          retries: {},
          args: {
            instance: rpcReq.instance,
            fileType: rpcReq.fileType,
            fileName: rpcReq.fileName,
            targetFileName: rpcReq.targetFileName
          }
        };
        for (channel in sessionContext.channels) {
          if (sessionContext.retries[channel] != null) {
            operation.retries[channel] = sessionContext.retries[channel];
          }
        }
        sessionContext.operations[rpcReq.commandKey] = operation;
        if (sessionContext.operationsTouched == null) {
          sessionContext.operationsTouched = {};
        }
        sessionContext.operationsTouched[rpcReq.commandKey] = 1;
      }
      break;
    default:
      return callback(new Error('Response name not recognized'));
  }
  return clear(sessionContext, toClear, callback);
};

rpcFault = function(sessionContext, id, faultResponse, callback) {
  var fault;
  fault = {
    code: "cwmp." + faultResponse.detail.faultCode,
    message: faultResponse.detail.faultString,
    detail: faultResponse.detail,
    timestamp: sessionContext.timestamp
  };
  delete sessionContext.syncState;
  return callback(null, fault);
};

deserialize = function(sessionContextString, callback) {
  return localCache.getProvisionsAndVirtualParameters(function(err, hash, provisions, virtualParameters) {
    var d, decs, deviceData, len, len1, len2, m, o, path, q, r, ref, ref1, sessionContext;
    if (err) {
      return callback(err);
    }
    sessionContext = JSON.parse(sessionContextString);
    if ((sessionContext.presetsHash != null) && sessionContext.presetsHash !== hash) {
      return callback(new Error('Preset hash mismatch'));
    }
    provisionsCache.set(sessionContext, provisions);
    virtualParametersCache.set(sessionContext, virtualParameters);
    ref = sessionContext.declarations;
    for (m = 0, len = ref.length; m < len; m++) {
      decs = ref[m];
      for (o = 0, len1 = decs.length; o < len1; o++) {
        d = decs[o];
        common.addPathMeta(d[0]);
      }
    }
    deviceData = initDeviceData();
    ref1 = sessionContext.deviceData;
    for (q = 0, len2 = ref1.length; q < len2; q++) {
      r = ref1[q];
      path = deviceData.paths.add(r[0]);
      if (r[1]) {
        deviceData.loaded.set(path, r[1]);
      }
      if (r[2]) {
        deviceData.trackers.set(path, r[2]);
      }
      if (r[3]) {
        deviceData.timestamps.setRevisions(path, r[3]);
        if (r[4]) {
          deviceData.attributes.setRevisions(path, r[4]);
        }
      }
    }
    sessionContext.deviceData = deviceData;
    return callback(null, sessionContext);
  });
};

serialize = function(sessionContext, callback) {
  var deviceData, e, len, m, path, ref, sessionContextString;
  deviceData = [];
  ref = sessionContext.deviceData.paths.find([], false, false, 99);
  for (m = 0, len = ref.length; m < len; m++) {
    path = ref[m];
    e = [path];
    e[1] = sessionContext.deviceData.loaded.get(path) || 0;
    e[2] = sessionContext.deviceData.trackers.get(path) || null;
    e[3] = sessionContext.deviceData.timestamps.getRevisions(path) || null;
    e[4] = sessionContext.deviceData.attributes.getRevisions(path) || null;
    deviceData.push(e);
  }
  sessionContext = Object.assign({}, sessionContext);
  sessionContext.deviceData = deviceData;
  delete sessionContext.syncState;
  delete sessionContext.toLoad;
  delete sessionContext.httpRequest;
  delete sessionContext.httpResponse;
  sessionContextString = JSON.stringify(sessionContext);
  return callback(null, sessionContextString);
};

exports.init = init;

exports.timeoutOperations = timeoutOperations;

exports.inform = inform;

exports.transferComplete = transferComplete;

exports.addProvisions = addProvisions;

exports.clearProvisions = clearProvisions;

exports.rpcRequest = rpcRequest;

exports.rpcResponse = rpcResponse;

exports.rpcFault = rpcFault;

exports.serialize = serialize;

exports.deserialize = deserialize;
