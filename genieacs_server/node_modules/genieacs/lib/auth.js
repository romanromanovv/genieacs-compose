// Generated by CoffeeScript 1.12.7

/*
 * Copyright 2013-2017  Zaid Abdulla
 *
 * This file is part of GenieACS.
 *
 * GenieACS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * GenieACS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with GenieACS.  If not, see <http://www.gnu.org/licenses/>.
 */
var crypto;

crypto = require('crypto');

exports.parseAuthHeader = function(authHeader) {
  var method, name, p, part, parts, res, value;
  authHeader = authHeader.trim();
  method = authHeader.split(' ', 1)[0];
  res = {
    method: method
  };
  parts = authHeader.slice(method.length + 1).split(',');
  while ((part = parts.shift()) != null) {
    name = part.split('=', 1)[0];
    if (name.length === part.length) {
      throw new Error('Unable to parse auth header');
    }
    value = part.slice(name.length + 1);
    if (!/^\s*"/.test(value)) {
      value = value.trim();
    } else {
      while (!/[^\\]"\s*$/.test(value)) {
        p = parts.shift();
        if (p == null) {
          throw new Error('Unable to parse auth header');
        }
        value += ',' + p;
      }
      try {
        value = JSON.parse(value);
      } catch (error) {
        throw new Error('Unable to parse auth header');
      }
    }
    res[name.trim()] = value;
  }
  return res;
};

exports.basic = function(username, password) {
  return "Basic " + (new Buffer(username + ":" + password).toString('base64'));
};

exports.digest = function(username, password, uri, httpMethod, body, authHeader) {
  var authString, cnonce, ha1, ha2, nc, qop, response;
  cnonce = '0a4f113b';
  nc = '00000001';
  if (authHeader.qop != null) {
    if (authHeader.qop.indexOf(',') !== -1) {
      qop = 'auth';
    } else {
      qop = authHeader.qop;
    }
  }
  ha1 = crypto.createHash('md5');
  ha1.update(username).update(':').update(authHeader.realm).update(':').update(password);
  ha1 = ha1.digest('hex');
  ha2 = crypto.createHash('md5');
  ha2.update(httpMethod).update(':').update(uri);
  if (qop === 'auth-int') {
    ha2.update(':').update(body);
  }
  ha2 = ha2.digest('hex');
  response = crypto.createHash('md5');
  response.update(ha1).update(':').update(authHeader.nonce);
  if (qop != null) {
    response.update(':').update(nc).update(':').update(cnonce).update(':').update(qop);
  }
  response.update(':').update(ha2);
  response = response.digest('hex');
  authString = "Digest username=\"" + username + "\"";
  authString += ",realm=\"" + authHeader.realm + "\"";
  authString += ",nonce=\"" + authHeader.nonce + "\"";
  authString += ",uri=\"" + uri + "\"";
  if (authHeader.algorithm != null) {
    authString += ",algorithm=" + authHeader.algorithm;
  }
  if (qop != null) {
    authString += ",qop=" + qop + ",nc=" + nc + ",cnonce=\"" + cnonce + "\"";
  }
  authString += ",response=\"" + response + "\"";
  if (authHeader.opaque != null) {
    authString += ",opaque=\"" + authHeader.opaque + "\"";
  }
  return authString;
};
