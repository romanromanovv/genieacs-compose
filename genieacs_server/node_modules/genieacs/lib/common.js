// Generated by CoffeeScript 1.12.7

/*
 * Copyright 2013-2017  Zaid Abdulla
 *
 * This file is part of GenieACS.
 *
 * GenieACS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * GenieACS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with GenieACS.  If not, see <http://www.gnu.org/licenses/>.
 */
var ARRAY_TYPE, BOOLEAN_TYPE, DATE_TYPE, NULL_TYPE, NUMBER_TYPE, OBJECT_TYPE, REGEXP_TYPE, STRING_TYPE, UNDEFINED_TYPE, addPathMeta, buffer, escapeRegExp, parseAlias, parsePath, pathOverlap, typeOf;

buffer = require('buffer');

UNDEFINED_TYPE = '[object Undefined]';

NULL_TYPE = '[object Null]';

BOOLEAN_TYPE = '[object Boolean]';

NUMBER_TYPE = '[object Number]';

STRING_TYPE = '[object String]';

ARRAY_TYPE = '[object Array]';

OBJECT_TYPE = '[object Object]';

REGEXP_TYPE = '[object RegExp]';

DATE_TYPE = '[object Date]';

typeOf = function(obj) {
  return Object.prototype.toString.call(obj);
};

exports.generateDeviceId = function(deviceIdStruct) {
  var esc;
  esc = function(str) {
    return str.replace(/[^A-Za-z0-9_]/g, function(chr) {
      var b, buf, l, len, rep;
      buf = new buffer.Buffer(chr, 'utf8');
      rep = '';
      for (l = 0, len = buf.length; l < len; l++) {
        b = buf[l];
        rep += "%" + (b.toString(16).toUpperCase());
      }
      return rep;
    });
  };
  if (deviceIdStruct['ProductClass']) {
    return (esc(deviceIdStruct['OUI'])) + "-" + (esc(deviceIdStruct['ProductClass'])) + "-" + (esc(deviceIdStruct['SerialNumber']));
  }
  return (esc(deviceIdStruct['OUI'])) + "-" + (esc(deviceIdStruct['SerialNumber']));
};

exports.getParamValueFromPath = function(obj, path) {
  var err, l, len, p, pp, ref;
  pp = path.split('.');
  ref = obj;
  try {
    for (l = 0, len = pp.length; l < len; l++) {
      p = pp[l];
      ref = ref[p];
    }
    return ref;
  } catch (error) {
    err = error;
    return void 0;
  }
};

pathOverlap = function(a, b, start) {
  var i, l, ref1, ref2, res;
  if (a.length === b.length) {
    res = 3;
  } else if (a.length > b.length) {
    res = 2;
  } else {
    res = 1;
  }
  for (i = l = ref1 = start != null ? start : 0, ref2 = Math.min(a.length, b.length); l < ref2; i = l += 1) {
    if (a[i] != null) {
      if (b[i] == null) {
        res &= 2;
      } else if (a[i] !== b[i]) {
        return 0;
      }
    } else if (b[i] != null) {
      res &= 1;
    }
    if (!res) {
      return 0;
    }
  }
  return res;
};

parseAlias = function(pattern, start, res) {
  var alias, aliases, err, i, j, ref1, srt, value;
  aliases = [];
  i = start;
  while (i < pattern.length && pattern[i] !== ']') {
    alias = [];
    i = j = parsePath(pattern, i, alias) + 1;
    while ((ref1 = pattern[j]) !== ']' && ref1 !== ',') {
      if (pattern[j] === '"' && i === j) {
        ++j;
        while (pattern[j] !== '"' || pattern[j - 1] === '\\') {
          if (++j >= pattern.length) {
            throw new Error('Invalid alias expression');
          }
        }
      }
      if (++j >= pattern.length) {
        throw new Error('Invalid alias expression');
      }
    }
    value = pattern.slice(i, j).trim();
    i = j;
    if (value[0] === '"') {
      try {
        value = JSON.parse(value);
      } catch (error) {
        err = error;
        throw new Error('Invalid alias expression');
      }
    }
    alias.push(value);
    aliases.push(alias);
    if (pattern[i] === ',') {
      ++i;
    }
  }
  srt = function(a, b) {
    var k, l, m, ref2, ref3;
    for (j = l = 0, ref2 = Math.min(a.length, b.length); l < ref2; j = l += 2) {
      for (k = m = 0, ref3 = Math.min(a[j].length, b[j].length); m < ref3; k = m += 1) {
        if (Array.isArray(a[j][k])) {
          if (Array.isArray(b[j][k])) {
            return srt(a[j][k], b[j][k]);
          } else if (b[j][k] == null) {
            return -1;
          } else {
            return 1;
          }
        } else if (a[j][k] == null) {
          if (b[j][k] == null) {
            return 0;
          } else {
            return 1;
          }
        } else if ((b[j][k] == null) || Array.isArray(b[j][k])) {
          return -1;
        } else if (a[j][k] > b[j][k]) {
          return 1;
        } else if (a[j][k] < b[j][k]) {
          return -1;
        }
      }
      if (a[j].length > b[j].length) {
        return -1;
      } else if (a[j].length < b[j].length) {
        return 1;
      }
      if (a[j + 1] > b[j + 1]) {
        return -1;
      } else if (a[j + 1] < b[j + 1]) {
        return 1;
      }
    }
    if (a.length > b.length) {
      return -1;
    } else if (a.length < b.length) {
      return 1;
    }
    return 0;
  };
  aliases.sort(srt);
  res.push([].concat.apply([], aliases));
  return i;
};

parsePath = function(pattern, start, res) {
  var i, j, n, path;
  path = [];
  path.wildcard = 0;
  path.alias = 0;
  i = start != null ? start : 0;
  if (i < pattern.length && pattern[i] !== ':') {
    while (true) {
      if (pattern[i] === '[') {
        path.alias |= 1 << path.length;
        i = parseAlias(pattern, i + 1, path) + 1;
      } else {
        j = i;
        while (i < pattern.length && pattern[i] !== ':' && pattern[i] !== '.') {
          ++i;
        }
        n = pattern.slice(j, i);
        if (n === '*') {
          path.wildcard |= 1 << path.length;
        }
        path.push(n);
      }
      if (i >= pattern.length || pattern[i] === ':') {
        break;
      } else if (pattern[i] !== '.') {
        throw new Error('Invalid alias expression');
      }
      ++i;
    }
  }
  Object.freeze(path);
  if (res == null) {
    return path;
  }
  res.push(path);
  return i;
};

addPathMeta = function(path) {
  var i, j, l, len, m, p, ref1;
  if ((path.alias != null) || (path.wildcard != null)) {
    return path;
  }
  path.alias = 0;
  path.wildcard = 0;
  for (i = l = 0, len = path.length; l < len; i = ++l) {
    p = path[i];
    if (typeOf(p) === ARRAY_TYPE) {
      path.alias |= 1 << i;
      for (j = m = 0, ref1 = p.length; m < ref1; j = m += 2) {
        addPathMeta(p[j]);
      }
    } else if (p === '*') {
      path.wildcard |= 1 << i;
    }
  }
  Object.freeze(path);
  return path;
};

escapeRegExp = function(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
};

exports.UNDEFINED_TYPE = UNDEFINED_TYPE;

exports.NULL_TYPE = NULL_TYPE;

exports.NUMBER_TYPE = NUMBER_TYPE;

exports.STRING_TYPE = STRING_TYPE;

exports.ARRAY_TYPE = ARRAY_TYPE;

exports.OBJECT_TYPE = OBJECT_TYPE;

exports.REGEXP_TYPE = REGEXP_TYPE;

exports.typeOf = typeOf;

exports.pathOverlap = pathOverlap;

exports.parsePath = parsePath;

exports.addPathMeta = addPathMeta;

exports.escapeRegExp = escapeRegExp;
