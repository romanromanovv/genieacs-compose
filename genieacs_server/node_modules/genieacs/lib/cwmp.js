// Generated by CoffeeScript 1.12.7

/*
 * Copyright 2013-2017  Zaid Abdulla
 *
 * This file is part of GenieACS.
 *
 * GenieACS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * GenieACS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with GenieACS.  If not, see <http://www.gnu.org/licenses/>.
 */
var MAX_CONCURRENT_REQUESTS, MAX_CYCLES, appendProvisions, applyPresets, cache, cacheDueTasksAndFaultsAndOperations, common, config, crypto, currentSessions, db, device, endSession, getDueTasksAndFaultsAndOperations, getSession, inform, listener, localCache, logger, nextRpc, onConnection, processRequest, query, recordFault, scheduling, sendAcsRequest, session, soap, stats, throwError, transferComplete, util, writeResponse, zlib;

util = require('util');

zlib = require('zlib');

crypto = require('crypto');

config = require('./config');

common = require('./common');

soap = require('./soap');

session = require('./session');

query = require('./query');

device = require('./device');

cache = require('./cache');

localCache = require('./local-cache');

db = require('./db');

logger = require('./logger');

scheduling = require('./scheduling');

MAX_CYCLES = 4;

MAX_CONCURRENT_REQUESTS = config.get('MAX_CONCURRENT_REQUESTS');

stats = {
  concurrentRequests: 0,
  totalRequests: 0,
  droppedRequests: 0,
  initiatedSessions: 0
};

throwError = function(err, httpResponse) {
  if (httpResponse) {
    currentSessions["delete"](httpResponse.connection);
    httpResponse.writeHead(500, {
      'Connection': 'close'
    });
    httpResponse.end(err.name + ": " + err.message);
    stats.concurrentRequests -= 1;
  }
  throw err;
};

writeResponse = function(sessionContext, res, close) {
  var compress, dump, finish;
  if (close) {
    res.headers['Connection'] = 'close';
  }
  if (config.get('DEBUG', sessionContext.deviceId)) {
    dump = ("# RESPONSE " + (new Date(Date.now())) + "\n") + JSON.stringify(res.headers) + ("\n" + res.data + "\n\n");
    require('fs').appendFile("./debug/" + sessionContext.deviceId + ".dump", dump, function(err) {
      if (err) {
        return throwError(err);
      }
    });
  }
  finish = function() {
    stats.concurrentRequests -= 1;
    if (sessionContext.httpRequest.connection.destroyed) {
      return logger.accessError({
        sessionContext: sessionContext,
        message: 'Connection dropped'
      });
    } else if (close) {
      return endSession(sessionContext, function(err, isNew) {
        if (err) {
          return throwError(err);
        }
        if (isNew) {
          return logger.accessInfo({
            sessionContext: sessionContext,
            message: 'New device registered'
          });
        }
      });
    } else {
      sessionContext.lastActivity = Date.now();
      return currentSessions.set(sessionContext.httpRequest.connection, sessionContext);
    }
  };
  if ((sessionContext.httpRequest.headers['content-encoding'] != null) && res.data.length > 0) {
    switch (sessionContext.httpRequest.headers['content-encoding']) {
      case 'gzip':
        res.headers['Content-Encoding'] = 'gzip';
        compress = zlib.gzip;
        break;
      case 'deflate':
        res.headers['Content-Encoding'] = 'deflate';
        compress = zlib.deflate;
    }
  }
  if (compress != null) {
    return compress(res.data, function(err, data) {
      if (err) {
        return throwError(err, sessionContext.httpResponse);
      }
      res.headers['Content-Length'] = data.length;
      sessionContext.httpResponse.writeHead(res.code, res.headers);
      sessionContext.httpResponse.end(data);
      return finish();
    });
  } else {
    res.headers['Content-Length'] = res.data.length;
    sessionContext.httpResponse.writeHead(res.code, res.headers);
    sessionContext.httpResponse.end(res.data);
    return finish();
  }
};

recordFault = function(sessionContext, fault, provisions, channels) {
  var channel, faults, i, l, len, len1, m, provision, provs, ref, ref1, t, taskId;
  if (!provisions) {
    provisions = sessionContext.provisions;
    channels = sessionContext.channels;
  }
  faults = sessionContext.faults;
  for (channel in channels) {
    provs = ((ref = sessionContext.faults[channel]) != null ? ref.provisions : void 0) || [];
    faults[channel] = Object.assign({
      provisions: provs
    }, fault);
    if (channel.startsWith('task_')) {
      taskId = channel.slice(5);
      ref1 = sessionContext.tasks;
      for (l = 0, len = ref1.length; l < len; l++) {
        t = ref1[l];
        if (t._id === taskId && t.expiry) {
          faults[channel].expiry = t.expiry;
        }
      }
    }
    if (sessionContext.retries[channel] != null) {
      ++sessionContext.retries[channel];
    } else {
      sessionContext.retries[channel] = 0;
      if (Object.keys(channels).length !== 1) {
        faults[channel].retryNow = true;
      }
    }
    if (channels[channel] === 0) {
      faults[channel].precondition = true;
    }
    if (sessionContext.faultsTouched == null) {
      sessionContext.faultsTouched = {};
    }
    sessionContext.faultsTouched[channel] = true;
    logger.accessWarn({
      sessionContext: sessionContext,
      message: 'Channel has faulted',
      fault: fault,
      channel: channel,
      retries: sessionContext.retries[channel]
    });
  }
  for (i = m = 0, len1 = provisions.length; m < len1; i = ++m) {
    provision = provisions[i];
    for (channel in channels) {
      if ((channels[channel] >> i) & 1) {
        faults[channel].provisions.push(provision);
      }
    }
  }
  for (channel in channels) {
    provs = faults[channel].provisions;
    faults[channel].provisions = [];
    appendProvisions(faults[channel].provisions, provs);
  }
  session.clearProvisions(sessionContext);
};

inform = function(sessionContext, rpc) {
  return session.inform(sessionContext, rpc.cpeRequest, function(err, acsResponse) {
    var cookiesPath, res;
    if (err) {
      return throwError(err, sessionContext.httpResponse);
    }
    res = soap.response({
      id: rpc.id,
      acsResponse: acsResponse,
      cwmpVersion: sessionContext.cwmpVersion
    });
    if (!!(cookiesPath = config.get('COOKIES_PATH', sessionContext.deviceId))) {
      res.headers['Set-Cookie'] = "session=" + sessionContext.sessionId + "; Path=" + cookiesPath;
    } else {
      res.headers['Set-Cookie'] = "session=" + sessionContext.sessionId;
    }
    return writeResponse(sessionContext, res);
  });
};

transferComplete = function(sessionContext, rpc) {
  return session.transferComplete(sessionContext, rpc.cpeRequest, function(err, acsResponse, operation, fault) {
    var k, ref, res, v;
    if (err) {
      return throwError(err, sessionContext.httpResponse);
    }
    if (operation == null) {
      logger.accessWarn({
        sessionContext: sessionContext,
        message: 'Unrecognized command key',
        rpc: rpc
      });
    }
    if (fault) {
      ref = operation.retries;
      for (k in ref) {
        v = ref[k];
        sessionContext.retries[k] = v;
      }
      recordFault(sessionContext, fault, operation.provisions, operation.channels);
    }
    res = soap.response({
      id: rpc.id,
      acsResponse: acsResponse,
      cwmpVersion: sessionContext.cwmpVersion
    });
    return writeResponse(sessionContext, res);
  });
};

appendProvisions = function(original, toAppend) {
  var i, j, l, len, m, modified, n, p, pp, s, ss, stringified;
  modified = false;
  stringified = new WeakMap();
  for (i = l = 0, len = original.length; l < len; i = ++l) {
    p = original[i];
    stringified.set(p, JSON.stringify(p));
  }
  for (i = m = toAppend.length - 1; m >= 0; i = m += -1) {
    p = toAppend[i];
    s = JSON.stringify(p);
    for (j = n = original.length - 1; n >= 0; j = n += -1) {
      pp = original[j];
      ss = stringified.get(pp);
      if (s === ss) {
        if ((!p) || j >= original.length - (toAppend.length - i)) {
          p = null;
        } else {
          original.splice(j, 1);
          modified = true;
        }
      }
    }
    if (p) {
      original.splice(original.length - (toAppend.length - i) + 1, 0, p);
      stringified.set(p, s);
      modified = true;
    }
  }
  return modified;
};

applyPresets = function(sessionContext) {
  return localCache.getPresets(function(err, presetsHash, presets) {
    var RETRY_DELAY, blackList, channel, declarations, deviceEvents, eventsMatch, fault, filteredPresets, k, l, len, len1, m, p, parameters, preset, r, ref, ref1, ref2, ref3, ref4, retryTimestamp, v, whiteList, whiteListProvisions;
    if (err) {
      return throwError(err, sessionContext.httpResponse);
    }
    blackList = {};
    whiteList = null;
    whiteListProvisions = null;
    RETRY_DELAY = config.get('RETRY_DELAY', sessionContext.deviceId);
    if (sessionContext.faults != null) {
      ref = sessionContext.faults;
      for (channel in ref) {
        fault = ref[channel];
        if (fault.retryNow) {
          retryTimestamp = 0;
        } else {
          retryTimestamp = fault.timestamp + (RETRY_DELAY * Math.pow(2, sessionContext.retries[channel])) * 1000;
        }
        if (retryTimestamp <= sessionContext.timestamp) {
          whiteList = channel;
          whiteListProvisions = fault.provisions;
          break;
        }
        blackList[channel] = fault.precondition ? 1 : 2;
      }
    }
    sessionContext.deviceData.timestamps.revision = 1;
    sessionContext.deviceData.attributes.revision = 1;
    deviceEvents = {};
    ref1 = sessionContext.deviceData.paths.find(['Events', '*'], false, true);
    for (l = 0, len = ref1.length; l < len; l++) {
      p = ref1[l];
      if (sessionContext.timestamp <= ((ref2 = sessionContext.deviceData.attributes.get(p)) != null ? (ref3 = ref2.value) != null ? ref3[1][0] : void 0 : void 0)) {
        deviceEvents[p[1]] = true;
      }
    }
    parameters = {};
    filteredPresets = [];
    for (m = 0, len1 = presets.length; m < len1; m++) {
      preset = presets[m];
      if (whiteList != null) {
        if (preset.channel !== whiteList) {
          continue;
        }
      } else if (blackList[preset.channel] === 1) {
        continue;
      }
      eventsMatch = true;
      ref4 = preset.events;
      for (k in ref4) {
        v = ref4[k];
        if ((!v) !== (!deviceEvents[k.replace(' ', '_')])) {
          eventsMatch = false;
          break;
        }
      }
      if (!eventsMatch) {
        continue;
      }
      if (preset.schedule) {
        if (!preset.schedule.schedule) {
          continue;
        }
        r = scheduling.cron(sessionContext.timestamp, preset.schedule.schedule);
        if (!(r[0] + preset.schedule.duration > sessionContext.timestamp)) {
          continue;
        }
      }
      filteredPresets.push(preset);
      for (k in preset.precondition) {
        sessionContext.channels[preset.channel] = 0;
        p = k.split(/([^a-zA-Z0-9\-\_\.].*)/, 1)[0];
        parameters[p] = common.parsePath(p);
      }
    }
    declarations = [];
    for (k in parameters) {
      v = parameters[k];
      declarations.push([
        v, 1, {
          value: 1
        }
      ]);
    }
    return session.rpcRequest(sessionContext, declarations, function(err, fault, id, acsRequest) {
      var appendProvisionsToFaults, c, len2, n, provisions, ref5, unpacked, vv;
      if (err) {
        return throwError(err, sessionContext.httpResponse);
      }
      if (fault) {
        recordFault(sessionContext, fault);
        session.clearProvisions(sessionContext);
        return applyPresets(sessionContext);
      }
      if (acsRequest) {
        return sendAcsRequest(sessionContext, id, acsRequest);
      }
      session.clearProvisions(sessionContext);
      for (k in parameters) {
        v = parameters[k];
        unpacked = device.unpack(sessionContext.deviceData, v);
        if (unpacked[0] && ((vv = (ref5 = sessionContext.deviceData.attributes.get(unpacked[0]).value) != null ? ref5[1] : void 0) != null)) {
          parameters[k] = vv[0];
        } else {
          delete parameters[k];
        }
      }
      if (whiteList != null) {
        session.addProvisions(sessionContext, whiteList, whiteListProvisions);
      }
      appendProvisionsToFaults = {};
      for (n = 0, len2 = filteredPresets.length; n < len2; n++) {
        p = filteredPresets[n];
        if (query.testFilter(parameters, p.precondition)) {
          if (blackList[p.channel] === 2) {
            appendProvisionsToFaults[p.channel] = (appendProvisionsToFaults[p.channel] || []).concat(p.provisions);
          } else {
            session.addProvisions(sessionContext, p.channel, p.provisions);
          }
        }
      }
      for (channel in appendProvisionsToFaults) {
        provisions = appendProvisionsToFaults[channel];
        if (appendProvisions(sessionContext.faults[channel].provisions, provisions)) {
          if (sessionContext.faultsTouched == null) {
            sessionContext.faultsTouched = {};
          }
          sessionContext.faultsTouched[channel] = true;
        }
      }
      if (whiteList == null) {
        sessionContext.presetCycles = (sessionContext.presetCycles || 0) + 1;
      }
      if (sessionContext.presetCycles > MAX_CYCLES) {
        fault = {
          code: 'preset_loop',
          message: 'The presets are stuck in an endless configuration loop',
          timestamp: sessionContext.timestamp
        };
        recordFault(sessionContext, fault);
        for (c in sessionContext.faults) {
          delete sessionContext.faults[c].retryNow;
        }
        session.clearProvisions(sessionContext);
        return sendAcsRequest(sessionContext);
      }
      sessionContext.deviceData.timestamps.dirty = 0;
      sessionContext.deviceData.attributes.dirty = 0;
      return session.rpcRequest(sessionContext, null, function(err, fault, id, acsRequest) {
        var flags, ref6;
        if (err) {
          return throwError(err, sessionContext.httpResponse);
        }
        if (fault) {
          recordFault(sessionContext, fault);
          session.clearProvisions(sessionContext);
          return applyPresets(sessionContext);
        }
        if (!acsRequest) {
          ref6 = sessionContext.channels;
          for (channel in ref6) {
            flags = ref6[channel];
            if (channel in sessionContext.faults) {
              delete sessionContext.faults[channel];
              if (sessionContext.faultsTouched == null) {
                sessionContext.faultsTouched = {};
              }
              sessionContext.faultsTouched[channel] = true;
            }
          }
          if (whiteList != null) {
            return applyPresets(sessionContext);
          }
          if (sessionContext.deviceData.timestamps.dirty > 1 || sessionContext.deviceData.attributes.dirty > 1) {
            return applyPresets(sessionContext);
          }
        }
        return sendAcsRequest(sessionContext, id, acsRequest);
      });
    });
  });
};

nextRpc = function(sessionContext) {
  return session.rpcRequest(sessionContext, null, function(err, fault, id, acsRequest) {
    var alias, channel, flags, j, l, len, len1, len2, m, n, p, ref, ref1, ref2, ref3, t, task, taskId;
    if (err) {
      return throwError(err, sessionContext.httpResponse);
    }
    if (fault) {
      recordFault(sessionContext, fault);
      session.clearProvisions(sessionContext);
      return nextRpc(sessionContext);
    }
    if (acsRequest) {
      return sendAcsRequest(sessionContext, id, acsRequest);
    }
    ref = sessionContext.channels;
    for (channel in ref) {
      flags = ref[channel];
      if (flags && channel in sessionContext.faults) {
        delete sessionContext.faults[channel];
        if (sessionContext.faultsTouched == null) {
          sessionContext.faultsTouched = {};
        }
        sessionContext.faultsTouched[channel] = true;
      }
      if (channel.startsWith('task_')) {
        taskId = channel.slice(5);
        if (sessionContext.doneTasks == null) {
          sessionContext.doneTasks = [];
        }
        sessionContext.doneTasks.push(taskId);
        ref1 = sessionContext.tasks;
        for (j = l = 0, len = ref1.length; l < len; j = ++l) {
          t = ref1[j];
          if (t._id === taskId) {
            sessionContext.tasks.splice(j, 1);
            break;
          }
        }
      }
    }
    session.clearProvisions(sessionContext);
    sessionContext.tasks = sessionContext.tasks.filter(function(task) {
      if (!(task.expiry <= sessionContext.timestamp)) {
        return true;
      }
      logger.accessInfo({
        sessionContext: sessionContext,
        message: 'Task expired',
        task: task
      });
      if (sessionContext.doneTasks == null) {
        sessionContext.doneTasks = [];
      }
      sessionContext.doneTasks.push(task._id);
      channel = "task_" + task._id;
      if (channel in sessionContext.faults) {
        delete sessionContext.faults[channel];
        if (sessionContext.faultsTouched == null) {
          sessionContext.faultsTouched = {};
        }
        sessionContext.faultsTouched[channel] = true;
      }
      return false;
    });
    task = sessionContext.tasks.find(function(task) {
      return !sessionContext.faults["task_" + task._id];
    });
    if (!task) {
      return applyPresets(sessionContext);
    }
    switch (task.name) {
      case 'getParameterValues':
        sessionContext.channels["task_" + task._id] = 0;
        ref2 = task.parameterNames;
        for (m = 0, len1 = ref2.length; m < len1; m++) {
          p = ref2[m];
          session.addProvisions(sessionContext, "task_" + task._id, [['refresh', p]]);
        }
        break;
      case 'setParameterValues':
        sessionContext.channels["task_" + task._id] = 0;
        ref3 = task.parameterValues;
        for (n = 0, len2 = ref3.length; n < len2; n++) {
          p = ref3[n];
          session.addProvisions(sessionContext, "task_" + task._id, [['value', p[0], p[1]]]);
        }
        break;
      case 'refreshObject':
        session.addProvisions(sessionContext, "task_" + task._id, [['refresh', task.objectName]]);
        break;
      case 'reboot':
        session.addProvisions(sessionContext, "task_" + task._id, [['reboot']]);
        break;
      case 'factoryReset':
        session.addProvisions(sessionContext, "task_" + task._id, [['reset']]);
        break;
      case 'download':
        session.addProvisions(sessionContext, "task_" + task._id, [['download', task.fileType, task.fileName, task.targetFileName]]);
        break;
      case 'addObject':
        alias = ((function() {
          var len3, o, ref4, results;
          ref4 = task.parameterValues || [];
          results = [];
          for (o = 0, len3 = ref4.length; o < len3; o++) {
            p = ref4[o];
            results.push(p[0] + ":" + (JSON.stringify(p[1])));
          }
          return results;
        })()).join(',');
        session.addProvisions(sessionContext, "task_" + task._id, [['instances', task.objectName + ".[" + alias + "]", "+1"]]);
        break;
      case 'deleteObject':
        session.addProvisions(sessionContext, "task_" + task._id, [['instances', task.objectName, 0]]);
        break;
      default:
        return throwError(new Error('Task name not recognized'), sessionContext.httpResponse);
    }
    return nextRpc(sessionContext);
  });
};

endSession = function(sessionContext, callback) {
  var counter, k, ref, saveCache;
  saveCache = sessionContext.cacheUntil != null;
  counter = 3;
  counter += 2;
  db.saveDevice(sessionContext.deviceId, sessionContext.deviceData, sessionContext["new"], sessionContext.timestamp, function(err) {
    if (err) {
      if (counter & 1) {
        callback(err);
      }
      return counter = 0;
    }
    if ((counter -= 2) === 1) {
      return callback(null, sessionContext["new"]);
    }
  });
  for (k in sessionContext.operationsTouched) {
    counter += 2;
    saveCache = true;
    if (sessionContext.operations[k] != null) {
      db.saveOperation(sessionContext.deviceId, k, sessionContext.operations[k], function(err) {
        if (err) {
          if (counter & 1) {
            callback(err);
          }
          return counter = 0;
        }
        if ((counter -= 2) === 1) {
          return callback(null, sessionContext["new"]);
        }
      });
    } else {
      db.deleteOperation(sessionContext.deviceId, k, function(err) {
        if (err) {
          if (counter & 1) {
            callback(err);
          }
          return counter = 0;
        }
        if ((counter -= 2) === 1) {
          return callback(null, sessionContext["new"]);
        }
      });
    }
  }
  if ((ref = sessionContext.doneTasks) != null ? ref.length : void 0) {
    counter += 2;
    saveCache = true;
    db.clearTasks(sessionContext.deviceId, sessionContext.doneTasks, function(err) {
      if (err) {
        if (counter & 1) {
          callback(err);
        }
        return counter = 0;
      }
      if ((counter -= 2) === 1) {
        return callback(null, sessionContext["new"]);
      }
    });
  }
  for (k in sessionContext.faultsTouched) {
    counter += 2;
    saveCache = true;
    if (sessionContext.faults[k]) {
      sessionContext.faults[k].retries = sessionContext.retries[k];
      db.saveFault(sessionContext.deviceId, k, sessionContext.faults[k], function(err) {
        if (err) {
          if (counter & 1) {
            callback(err);
          }
          return counter = 0;
        }
        if ((counter -= 2) === 1) {
          return callback(null, sessionContext["new"]);
        }
      });
    } else {
      db.deleteFault(sessionContext.deviceId, k, function(err) {
        if (err) {
          if (counter & 1) {
            callback(err);
          }
          return counter = 0;
        }
        if ((counter -= 2) === 1) {
          return callback(null, sessionContext["new"]);
        }
      });
    }
  }
  if (saveCache) {
    counter += 2;
    cacheDueTasksAndFaultsAndOperations(sessionContext.deviceId, sessionContext.tasks, sessionContext.faults, sessionContext.operations, sessionContext.cacheUntil, function(err) {
      if (err) {
        if (counter & 1) {
          callback(err);
        }
        return counter = 0;
      }
      if ((counter -= 2) === 1) {
        return callback(null, sessionContext["new"]);
      }
    });
  }
  if ((counter -= 2) === 1) {
    return callback(null, sessionContext["new"]);
  }
};

sendAcsRequest = function(sessionContext, id, acsRequest) {
  var FS_HOSTNAME, FS_PORT, FS_SSL, res, rpc;
  if (acsRequest == null) {
    return writeResponse(sessionContext, soap.response(null), true);
  }
  if (acsRequest.name === 'Download') {
    if (acsRequest.url == null) {
      FS_PORT = config.get('FS_PORT');
      FS_HOSTNAME = config.get('FS_HOSTNAME');
      FS_SSL = config.get('FS_SSL');
      acsRequest.url = FS_SSL ? 'https://' : 'http://';
      acsRequest.url += FS_HOSTNAME;
      if (FS_PORT !== 80) {
        acsRequest.url += ":" + FS_PORT;
      }
      acsRequest.url += "/" + (encodeURI(acsRequest.fileName));
    }
    if (acsRequest.fileSize == null) {
      return localCache.getFiles(function(err, hash, files) {
        if (err) {
          return throwError(err, sessionContext.httpResponse);
        }
        if (acsRequest.fileName in files) {
          acsRequest.fileSize = files[acsRequest.fileName].length;
        } else {
          acsRequest.fileSize = 0;
        }
        return sendAcsRequest(sessionContext, id, acsRequest);
      });
    }
  }
  rpc = {
    id: id,
    acsRequest: acsRequest,
    cwmpVersion: sessionContext.cwmpVersion
  };
  logger.accessInfo({
    sessionContext: sessionContext,
    message: 'ACS request',
    rpc: rpc
  });
  res = soap.response(rpc);
  return writeResponse(sessionContext, res);
};

getSession = function(connection, sessionId, callback) {
  var sessionContext;
  sessionContext = currentSessions.get(connection);
  if (sessionContext) {
    currentSessions["delete"](connection);
    return callback(null, sessionContext);
  }
  if (!sessionId) {
    return callback();
  }
  return setTimeout(function() {
    return cache.pop("session_" + sessionId, function(err, sessionContextString) {
      if (err || !sessionContextString) {
        return callback(err);
      }
      return session.deserialize(sessionContextString, callback);
    });
  }, 100);
};

currentSessions = new WeakMap();

onConnection = function(socket) {
  socket.remoteAddress;
  return socket.on('close', function() {
    var lastActivity, now, sessionContext, timeout, timeoutMsg;
    sessionContext = currentSessions.get(socket);
    if (!sessionContext) {
      return;
    }
    currentSessions["delete"](socket);
    now = Date.now();
    lastActivity = sessionContext.lastActivity;
    timeoutMsg = logger.flatten({
      sessionContext: sessionContext,
      message: 'Session timeout',
      sessionTimestamp: sessionContext.timestamp
    });
    timeout = (sessionContext.lastActivity + sessionContext.timeout * 1000) - now;
    if (timeout <= 0) {
      return logger.accessError(timeoutMsg);
    }
    setTimeout(function() {
      return cache.get("session_" + sessionContext.sessionId, function(err, sessionContextString) {
        if (err) {
          return throwError(err);
        }
        if (!sessionContextString) {
          return;
        }
        return session.deserialize(sessionContextString, function(err, sessionContext) {
          if (err) {
            return throwError(err);
          }
          if (sessionContext.lastActivity === lastActivity) {
            return logger.accessError(timeoutMsg);
          }
        });
      });
    }, timeout + 1000).unref();
    return session.serialize(sessionContext, function(err, sessionContextString) {
      if (err) {
        return throwError(err);
      }
      return cache.set("session_" + sessionContext.sessionId, sessionContextString, Math.ceil(timeout / 1000) + 3, function(err) {
        if (err) {
          return throwError(err);
        }
      });
    });
  });
};

setInterval(function() {
  if (stats.droppedRequests) {
    logger.warn({
      message: 'Worker overloaded',
      droppedRequests: stats.droppedRequests,
      totalRequests: stats.totalRequests,
      initiatedSessions: stats.initiatedSessions,
      pid: process.pid
    });
  }
  stats.totalRequests = 0;
  stats.droppedRequests = 0;
  return stats.initiatedSessions = 0;
}, 10000).unref();

getDueTasksAndFaultsAndOperations = function(deviceId, timestamp, callback) {
  return cache.get(deviceId + "_tasks_faults_operations", function(err, res) {
    var cacheUntil, faults, operations, tasks;
    if (err) {
      return callback(err);
    }
    if (res) {
      res = JSON.parse(res);
      return callback(null, res.tasks || [], res.faults || {}, res.operations || {});
    }
    faults = tasks = operations = cacheUntil = null;
    db.getFaults(deviceId, function(err, _faults) {
      if (err) {
        if (typeof callback === "function") {
          callback(err);
        }
        return callback = null;
      }
      faults = _faults;
      if ((tasks != null) && (operations != null)) {
        return callback(null, tasks, faults, operations, cacheUntil);
      }
    });
    db.getDueTasks(deviceId, timestamp, function(err, dueTasks, nextTimestamp) {
      if (err) {
        if (typeof callback === "function") {
          callback(err);
        }
        return callback = null;
      }
      tasks = dueTasks;
      cacheUntil = nextTimestamp || 0;
      if ((faults != null) && (operations != null)) {
        return callback(null, tasks, faults, operations, cacheUntil);
      }
    });
    db.getOperations(deviceId, function(err, _operations) {
      if (err) {
        if (typeof callback === "function") {
          callback(err);
        }
        return callback = null;
      }
      operations = _operations;
      if ((faults != null) && (tasks != null)) {
        return callback(null, tasks, faults, operations, cacheUntil);
      }
    });
    if ((faults != null) && (tasks != null) && (operations != null)) {
      return callback(null, tasks, faults, operations, cacheUntil);
    }
  });
};

cacheDueTasksAndFaultsAndOperations = function(deviceId, tasks, faults, operations, cacheUntil, callback) {
  var ttl, v;
  v = {};
  if (tasks.length) {
    v.tasks = tasks;
  }
  if (Object.keys(faults).length) {
    v.faults = faults;
  }
  if (Object.keys(operations).length) {
    v.operations = operations;
  }
  if (cacheUntil) {
    ttl = Math.trunc((Date.now() - cacheUntil) / 1000);
  } else {
    ttl = config.get('MAX_CACHE_TTL', deviceId);
  }
  return cache.set(deviceId + "_tasks_faults_operations", JSON.stringify(v), ttl, callback);
};

processRequest = function(sessionContext, rpc) {
  var res;
  if (rpc.cpeRequest != null) {
    if (rpc.cpeRequest.name === 'Inform') {
      logger.accessInfo({
        sessionContext: sessionContext,
        message: 'Inform',
        rpc: rpc
      });
      return inform(sessionContext, rpc);
    } else if (rpc.cpeRequest.name === 'TransferComplete') {
      logger.accessInfo({
        sessionContext: sessionContext,
        message: 'CPE request',
        rpc: rpc
      });
      return transferComplete(sessionContext, rpc);
    } else if (rpc.cpeRequest.name === 'GetRPCMethods') {
      logger.accessInfo({
        sessionContext: sessionContext,
        message: 'CPE request',
        rpc: rpc
      });
      res = soap.response({
        id: rpc.id,
        acsResponse: {
          name: 'GetRPCMethodsResponse',
          methodList: ['Inform', 'GetRPCMethods', 'TransferComplete']
        },
        cwmpVersion: sessionContext.cwmpVersion
      });
      return writeResponse(sessionContext, res);
    } else {
      return throwError(new Error('ACS method not supported'), sessionContext.httpResponse);
    }
  } else if (rpc.cpeResponse) {
    return session.rpcResponse(sessionContext, rpc.id, rpc.cpeResponse, function(err) {
      if (err) {
        return throwError(err, sessionContext.httpResponse);
      }
      return nextRpc(sessionContext);
    });
  } else if (rpc.cpeFault) {
    logger.accessWarn({
      sessionContext: sessionContext,
      message: 'CPE fault',
      rpc: rpc
    });
    return session.rpcFault(sessionContext, rpc.id, rpc.cpeFault, function(err, fault) {
      if (err) {
        return throwError(err, sessionContext.httpResponse);
      }
      if (fault) {
        recordFault(sessionContext, fault);
        session.clearProvisions(sessionContext);
      }
      return nextRpc(sessionContext);
    });
  } else {
    return session.timeoutOperations(sessionContext, function(err, faults, operations) {
      var fault, i, k, l, len, ref, v;
      if (err) {
        return throwError(err, sessionContext.httpResponse);
      }
      for (i = l = 0, len = faults.length; l < len; i = ++l) {
        fault = faults[i];
        ref = operations[i].retries;
        for (k in ref) {
          v = ref[k];
          sessionContext.retries[k] = v;
        }
        recordFault(sessionContext, fault, operations[i].provisions, operations[i].channels);
      }
      return nextRpc(sessionContext);
    });
  }
};

listener = function(httpRequest, httpResponse) {
  var COOKIE_REGEX, bytes, chunks, match, sessionId, stream;
  stats.totalRequests += 1;
  if (httpRequest.method !== 'POST') {
    httpResponse.writeHead(405, {
      'Allow': 'POST',
      'Connection': 'close'
    });
    httpResponse.end('405 Method Not Allowed');
    return;
  }
  sessionId = null;
  COOKIE_REGEX = /\s*([a-zA-Z0-9\-_]+?)\s*=\s*"?([a-zA-Z0-9\-_]*?)"?\s*(,|;|$)/g;
  while (match = COOKIE_REGEX.exec(httpRequest.headers.cookie)) {
    if (match[1] === 'session') {
      sessionId = match[2];
    }
  }
  if (!sessionId && stats.concurrentRequests > MAX_CONCURRENT_REQUESTS) {
    httpResponse.writeHead(503, {
      'Retry-after': 60,
      'Connection': 'close'
    });
    httpResponse.end('503 Service Unavailable');
    stats.droppedRequests += 1;
    return;
  }
  if (httpRequest.headers['content-encoding'] != null) {
    switch (httpRequest.headers['content-encoding']) {
      case 'gzip':
        stream = httpRequest.pipe(zlib.createGunzip());
        break;
      case 'deflate':
        stream = httpRequest.pipe(zlib.createInflate());
        break;
      default:
        httpResponse.writeHead(415, {
          'Connection': 'close'
        });
        httpResponse.end('415 Unsupported Media Type');
        return;
    }
  } else {
    stream = httpRequest;
  }
  stats.concurrentRequests += 1;
  httpRequest.on('aborted', function() {
    stats.concurrentRequests -= 1;
    return httpRequest.removeAllListeners('end');
  });
  chunks = [];
  bytes = 0;
  stream.on('data', function(chunk) {
    chunks.push(chunk);
    return bytes += chunk.length;
  });
  return stream.on('end', function() {
    var body, offset, parsedRpc;
    body = new Buffer(bytes);
    offset = 0;
    chunks.forEach(function(chunk) {
      chunk.copy(body, offset, 0, chunk.length);
      return offset += chunk.length;
    });
    parsedRpc = function(sessionContext, rpc, parseWarnings) {
      var dump, l, len, w;
      for (l = 0, len = parseWarnings.length; l < len; l++) {
        w = parseWarnings[l];
        w.sessionContext = sessionContext;
        w.rpc = rpc;
        logger.accessWarn(w);
      }
      if (config.get('DEBUG', sessionContext.deviceId)) {
        dump = ("# REQUEST " + (new Date(Date.now())) + "\n") + JSON.stringify(httpRequest.headers) + ("\n" + body + "\n\n");
        require('fs').appendFile("./debug/" + sessionContext.deviceId + ".dump", dump, function(err) {
          if (err) {
            return throwError(err);
          }
        });
      }
      return processRequest(sessionContext, rpc);
    };
    return getSession(httpRequest.connection, sessionId, function(err, sessionContext) {
      var deviceId, parseWarnings, ref, ref1, ref2, rpc;
      if (err) {
        return throwError(err, httpResponse);
      }
      if (sessionContext) {
        sessionContext.httpRequest = httpRequest;
        sessionContext.httpResponse = httpResponse;
        if (sessionContext.sessionId !== sessionId || sessionContext.lastActivity + sessionContext.timeout * 1000 < Date.now()) {
          logger.accessError({
            message: 'Invalid session',
            sessionContext: sessionContext
          });
          httpResponse.writeHead(400, {
            'Connection': 'close'
          });
          httpResponse.end('Invalid session');
          stats.concurrentRequests -= 1;
          return;
        }
      } else if (stats.concurrentRequests > MAX_CONCURRENT_REQUESTS) {
        httpResponse.writeHead(503, {
          'Retry-after': 60,
          'Connection': 'close'
        });
        httpResponse.end('503 Service Unavailable');
        stats.droppedRequests += 1;
        stats.concurrentRequests -= 1;
        return;
      }
      parseWarnings = [];
      try {
        rpc = soap.request(body, sessionContext != null ? sessionContext.cwmpVersion : void 0, parseWarnings);
      } catch (error) {
        err = error;
        logger.accessError({
          message: 'XML parse error',
          parseError: err.message.trim(),
          sessionContext: sessionContext || {
            httpRequest: httpRequest,
            httpResponse: httpResponse
          }
        });
        httpResponse.writeHead(400, {
          'Connection': 'close'
        });
        httpResponse.end(err.message);
        stats.concurrentRequests -= 1;
        return;
      }
      if (sessionContext) {
        if (((ref = rpc.cpeRequest) != null ? ref.name : void 0) === 'Inform' || (!sessionContext.rpcRequest ^ !(rpc.cpeResponse || rpc.cpeFault))) {
          logger.accessError({
            message: 'Bad session state',
            sessionContext: sessionContext
          });
          httpResponse.writeHead(400, {
            'Connection': 'close'
          });
          httpResponse.end('Bad session state');
          stats.concurrentRequests -= 1;
          return;
        }
        return parsedRpc(sessionContext, rpc, parseWarnings);
      }
      if (((ref1 = rpc.cpeRequest) != null ? ref1.name : void 0) !== 'Inform') {
        logger.accessError({
          message: 'Invalid session',
          sessionContext: sessionContext || {
            httpRequest: httpRequest,
            httpResponse: httpResponse
          }
        });
        httpResponse.writeHead(400, {
          'Connection': 'close'
        });
        httpResponse.end('Invalid session');
        stats.concurrentRequests -= 1;
        return;
      }
      stats.initiatedSessions += 1;
      deviceId = common.generateDeviceId(rpc.cpeRequest.deviceId);
      return session.init(deviceId, rpc.cwmpVersion, (ref2 = rpc.sessionTimeout) != null ? ref2 : config.get('SESSION_TIMEOUT', deviceId), function(err, sessionContext) {
        if (err) {
          return throwError(err, httpResponse);
        }
        sessionContext.httpRequest = httpRequest;
        sessionContext.httpResponse = httpResponse;
        sessionContext.sessionId = crypto.randomBytes(8).toString('hex');
        httpRequest.connection.setTimeout(sessionContext.timeout * 1000);
        return getDueTasksAndFaultsAndOperations(deviceId, sessionContext.timestamp, function(err, dueTasks, faults, operations, cacheUntil) {
          var k, ref3, v;
          if (err) {
            return throwError(err, httpResponse);
          }
          sessionContext.tasks = dueTasks;
          sessionContext.faults = faults;
          sessionContext.retries = {};
          for (k in faults) {
            v = faults[k];
            sessionContext.retries[k] = v.retries;
          }
          sessionContext.operations = operations;
          sessionContext.cacheUntil = cacheUntil;
          ref3 = sessionContext.faults;
          for (k in ref3) {
            v = ref3[k];
            if (v.expiry >= sessionContext.timestamp) {
              delete sessionContext.faults[k];
              if (sessionContext.faultsTouched == null) {
                sessionContext.faultsTouched = {};
              }
              sessionContext.faultsTouched[k] = true;
            }
          }
          return parsedRpc(sessionContext, rpc, parseWarnings);
        });
      });
    });
  });
};

exports.listener = listener;

exports.onConnection = onConnection;
