// Generated by CoffeeScript 1.12.7

/*
 * Copyright 2013-2017  Zaid Abdulla
 *
 * This file is part of GenieACS.
 *
 * GenieACS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * GenieACS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with GenieACS.  If not, see <http://www.gnu.org/licenses/>.
 *
 * This file incorporates work covered by the following copyright and
 * permission notice:
 *
 * Copyright 2013 Fanoos Telecom
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var common, convertMongoQueryToFilters, expand, expandValue, matchType, mongodb, normalize, permute, queryProjection, sanitizeQueryTypes, stringToRegexp, test, testExpressions, testFilter;

common = require('./common');

mongodb = require('mongodb');

stringToRegexp = function(input, flags) {
  var output;
  if (input.indexOf('*') === -1) {
    return false;
  }
  output = input.replace(/[\[\]\\\^\$\.\|\?\+\(\)]/, "\\$&");
  if (output[0] === '*') {
    output = output.replace(/^\*+/g, '');
  } else {
    output = '^' + output;
  }
  if (output[output.length - 1] === '*') {
    output = output.replace(/\*+$/g, '');
  } else {
    output = output + '$';
  }
  output = output.replace(/[\*]/, '.*');
  return new RegExp(output, flags);
};

normalize = function(input) {
  var d, m, r, vals;
  if (common.typeOf(input) === common.STRING_TYPE) {
    vals = [input];
    if ((m = /^\/(.*?)\/(g?i?m?y?)$/.exec(input))) {
      vals.push({
        '$regex': new RegExp(m[1], m[2])
      });
    }
    if (+input === parseFloat(input)) {
      vals.push(+input);
    }
    d = new Date(input);
    if (input.length >= 8 && d.getFullYear() > 1983) {
      vals.push(d);
    }
    r = stringToRegexp(input);
    if (r !== false) {
      vals.push({
        '$regex': r
      });
    }
    return vals;
  }
  return input;
};

expandValue = function(value) {
  var a, i, indices, j, k, keys, l, len, n, o, obj, objs, p, ref, ref1, v, values;
  if (common.typeOf(value) === common.ARRAY_TYPE) {
    a = [];
    for (l = 0, len = value.length; l < len; l++) {
      j = value[l];
      a = a.concat(expandValue(j));
    }
    return [a];
  } else if (common.typeOf(value) !== common.OBJECT_TYPE) {
    n = normalize(value);
    if (common.typeOf(n) !== common.ARRAY_TYPE) {
      return [n];
    } else {
      return n;
    }
  }
  objs = [];
  indices = [];
  keys = [];
  values = [];
  for (k in value) {
    v = value[k];
    keys.push(k);
    values.push(expandValue(v));
    indices.push(0);
  }
  i = 0;
  while (i < indices.length) {
    obj = {};
    for (i = o = 0, ref = keys.length; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      obj[keys[i]] = values[i][indices[i]];
    }
    objs.push(obj);
    for (i = p = 0, ref1 = indices.length; 0 <= ref1 ? p < ref1 : p > ref1; i = 0 <= ref1 ? ++p : --p) {
      indices[i] += 1;
      if (indices[i] < values[i].length) {
        break;
      }
      indices[i] = 0;
    }
  }
  return objs;
};

permute = function(param, val) {
  var conditions, l, len, obj, v, values;
  conditions = [];
  values = expandValue(val);
  if (param[param.lastIndexOf('.') + 1] !== '_') {
    param += '._value';
  }
  for (l = 0, len = values.length; l < len; l++) {
    v = values[l];
    obj = {};
    obj[param] = v;
    conditions.push(obj);
  }
  return conditions;
};

expand = function(query) {
  var c, conditions, e, expressions, k, l, len, len1, new_query, o, v;
  new_query = {};
  for (k in query) {
    v = query[k];
    if (k[0] === '$') {
      expressions = [];
      for (l = 0, len = v.length; l < len; l++) {
        e = v[l];
        expressions.push(expand(e));
      }
      new_query[k] = expressions;
    } else {
      conditions = permute(k, v);
      if (conditions.length > 1) {
        if (new_query['$and'] == null) {
          new_query['$and'] = [];
        }
        if (((v != null ? v['$ne'] : void 0) != null) || ((v != null ? v['$not'] : void 0) != null)) {
          if (Object.keys(v) > 1) {
            throw new Error("Cannot mix $ne or $not with other operators");
          }
          for (o = 0, len1 = conditions.length; o < len1; o++) {
            c = conditions[o];
            new_query['$and'].push(c);
          }
        } else {
          new_query['$and'].push({
            '$or': conditions
          });
        }
      } else {
        Object.assign(new_query, conditions[0]);
      }
    }
  }
  return new_query;
};

queryProjection = function(query, proj) {
  var k, l, len, q, v;
  if (proj == null) {
    proj = {};
  }
  for (k in query) {
    v = query[k];
    if (k.charAt(0) === '$') {
      for (l = 0, len = v.length; l < len; l++) {
        q = v[l];
        queryProjection(q, proj);
      }
    } else {
      proj[k] = 1;
    }
  }
  return proj;
};

testExpressions = function(params, expressions, lop) {
  var f, l, len, res;
  for (l = 0, len = expressions.length; l < len; l++) {
    f = expressions[l];
    res = test(params, f);
    switch (lop) {
      case '$and':
        if (!res) {
          return false;
        }
        break;
      case '$or':
        if (res) {
          return true;
        }
        break;
      case '$nor':
        if (res) {
          return false;
        }
    }
  }
  switch (lop) {
    case '$and':
      return true;
    case '$or':
      return false;
    case '$nor':
      return true;
    default:
      throw new Error('Unknown logical operator');
  }
};

test = function(params, query) {
  var k, k2, res, v, v2, value;
  for (k in query) {
    v = query[k];
    if (k.charAt(0) === '$') {
      res = testExpressions(params, v, k);
    } else {
      value = params[k];
      if (common.typeOf(v) !== common.OBJECT_TYPE) {
        if (common.typeOf(value) === common.ARRAY_TYPE) {
          res = value.indexOf(v) !== -1;
        } else {
          if (common.typeOf(v) === common.REGEXP_TYPE) {
            res = v.test(value);
          } else {
            res = v === value;
          }
        }
      } else {
        for (k2 in v) {
          v2 = v[k2];
          switch (k2) {
            case '$ne':
              if (common.typeOf(value) === common.ARRAY_TYPE) {
                res = value.indexOf(v2) === -1;
              } else {
                res = value !== v2;
              }
              break;
            case '$lt':
              res = value < v2;
              break;
            case '$lte':
              res = value <= v2;
              break;
            case '$gt':
              res = value > v2;
              break;
            case '$gte':
              res = value >= v2;
              break;
            case '$regex':
              res = v2.test(value);
              break;
            case '$in':
              throw new Error('Operator not supported');
              break;
            case '$nin':
              throw new Error('Operator not supported');
              break;
            case '$all':
              throw new Error('Operator not supported');
              break;
            case '$exists':
              throw new Error('Operator not supported');
              break;
            default:
              throw new Error('Operator not supported');
          }
        }
      }
    }
    if (!res) {
      return false;
    }
  }
  return true;
};

matchType = function(src, dst) {
  var v;
  if (typeof src === 'string') {
    return String(dst);
  } else if (typeof src === 'number') {
    if (+dst === parseFloat(dst)) {
      return +dst;
    } else if (!isNaN(Date.parse(dst))) {
      return Date.parse(dst);
    }
  } else if (typeof src === 'boolean') {
    v = String(dst).trim();
    if (v === 'true' || v === 'TRUE' || v === 'True' || v === '1') {
      return true;
    } else if (v === 'false' || v === 'FALSE' || v === 'False' || v === '0') {
      return false;
    }
  }
  return dst;
};

testFilter = function(obj, filter) {
  var k, op, param, ref, v, val;
  for (k in filter) {
    v = filter[k];
    ref = k.split(/([^a-zA-Z0-9\-\_\.].*)/, 2), param = ref[0], op = ref[1];
    val = matchType(obj[param], v);
    switch (op) {
      case '=':
      case void 0:
        if (obj[param] !== val) {
          return false;
        }
        break;
      case '>':
        if (!(obj[param] > val)) {
          return false;
        }
        break;
      case '>=':
        if (!(obj[param] >= val)) {
          return false;
        }
        break;
      case '<':
        if (!(obj[param] < val)) {
          return false;
        }
        break;
      case '<=':
        if (!(obj[param] <= val)) {
          return false;
        }
        break;
      case '!':
        if (obj[param] === val) {
          return false;
        }
        break;
      default:
        throw new Error("Unrecognized operator " + op);
    }
  }
  return true;
};

convertMongoQueryToFilters = function(query, filters) {
  var k, kk, l, len, v, vv;
  if (filters == null) {
    filters = {};
  }
  for (k in query) {
    v = query[k];
    if (k[0] === '$') {
      if (k === '$and') {
        for (l = 0, len = v.length; l < len; l++) {
          vv = v[l];
          convertMongoQueryToFilters(vv, filters);
        }
      } else {
        throw new Error("Operator " + k + " not supported");
      }
    } else if (k === '_tags') {
      if (common.typeOf(v) === common.OBJECT_TYPE) {
        for (kk in v) {
          vv = v[kk];
          vv = vv.replace(/[^a-zA-Z0-9\-]+/g, '_');
          switch (kk) {
            case '$ne':
              filters["Tags." + vv + "!"] = true;
              break;
            default:
              throw new Error("Operator " + kk + " not supported");
          }
        }
      } else {
        v = v.replace(/[^a-zA-Z0-9\-]+/g, '_');
        filters["Tags." + v] = true;
      }
    } else {
      switch (k) {
        case '_id':
          k = 'DeviceID.ID';
          break;
        case '_deviceId._Manufacturer':
          k = 'DeviceID.Manufacturer';
          break;
        case '_deviceId._OUI':
          k = 'DeviceID.OUI';
          break;
        case '_deviceId._ProductClass':
          k = 'DeviceID.ProductClass';
          break;
        case '_deviceId._SerialNumber':
          k = 'DeviceID.SerialNumber';
          break;
        case '_lastInform':
          k = 'Events.Inform';
          break;
        case '_lastBootstrap':
          k = 'Events.0_BOOTSTRAP';
          break;
        case '_lastBoot':
          k = 'Events.1_BOOT';
          break;
        case '_registered':
          k = 'Events.Registered';
      }
      if (common.typeOf(v) === common.OBJECT_TYPE) {
        for (kk in v) {
          vv = v[kk];
          switch (kk) {
            case '$eq':
              filters[k] = vv;
              break;
            case '$ne':
              filters[k + "!"] = vv;
              break;
            case '$lt':
              filters[k + "<"] = vv;
              break;
            case '$lte':
              filters[k + "<="] = vv;
              break;
            case '$gt':
              filters[k + ">"] = vv;
              break;
            case '$gte':
              filters[k + ">="] = vv;
              break;
            default:
              throw new Error("Oprator " + kk + " not supported");
          }
        }
      } else {
        filters[k] = v;
      }
    }
  }
  return filters;
};

sanitizeQueryTypes = function(query, types) {
  var i, k, kk, l, len, o, ref, v, vv;
  for (k in query) {
    v = query[k];
    if (k[0] === '$') {
      for (l = 0, len = v.length; l < len; l++) {
        vv = v[l];
        sanitizeQueryTypes(vv, types);
      }
    } else if (k in types) {
      if (common.typeOf(v) === common.OBJECT_TYPE) {
        for (kk in v) {
          vv = v[kk];
          switch (kk) {
            case '$in':
            case '$nin':
              for (i = o = 0, ref = vv.length; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
                vv[i] = types[k](vv[i]);
              }
              break;
            case '$eq':
            case '$gt':
            case '$gte':
            case '$lt':
            case '$lte':
            case '$ne':
              v[kk] = types[k](vv);
              break;
            case '$exists':
            case '$type':
              break;
            default:
              throw new Error('Operator not supported');
          }
        }
      } else {
        query[k] = types[k](query[k]);
      }
    }
  }
  return query;
};

exports.expand = expand;

exports.queryProjection = queryProjection;

exports.test = test;

exports.sanitizeQueryTypes = sanitizeQueryTypes;

exports.convertMongoQueryToFilters = convertMongoQueryToFilters;

exports.testFilter = testFilter;
