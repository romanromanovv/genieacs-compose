// Generated by CoffeeScript 1.12.7

/*
 * Copyright 2013-2017  Zaid Abdulla
 *
 * This file is part of GenieACS.
 *
 * GenieACS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * GenieACS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with GenieACS.  If not, see <http://www.gnu.org/licenses/>.
 */
var URL, auth, cache, common, config, connectionRequest, crypto, db, deleteDevice, dgram, http, httpConReq, insertTasks, sanitizeTask, udpConReq, util, watchTask;

crypto = require('crypto');

dgram = require('dgram');

config = require('./config');

db = require('./db');

http = require('http');

common = require('./common');

util = require('util');

URL = require('url');

auth = require('./auth');

cache = require('./cache');

udpConReq = function(address, un, key, callback) {
  var UDP_CONNECTION_REQUEST_PORT, client, cn, count, f, host, id, message, port, ref, sig, ts, uri;
  if (!address) {
    return false;
  }
  ref = address.split(':', 2), host = ref[0], port = ref[1];
  if (port === void 0) {
    port = 80;
  } else {
    port = parseInt(port);
    if (isNaN(port)) {
      return false;
    }
  }
  ts = Math.trunc(Date.now() / 1000);
  id = Math.trunc(Math.random() * 4294967295);
  cn = crypto.randomBytes(8).toString('hex');
  sig = crypto.createHmac('sha1', key).update("" + ts + id + un + cn).digest('hex');
  uri = "http://" + address + "?ts=" + ts + "&id=" + id + "&un=" + un + "&cn=" + cn + "&sig=" + sig;
  message = Buffer.from("GET " + uri + " HTTP/1.1\r\nHost: " + address + "\r\n\r\n");
  client = dgram.createSocket({
    type: 'udp4',
    reuseAddr: true
  });
  UDP_CONNECTION_REQUEST_PORT = config.get('UDP_CONNECTION_REQUEST_PORT');
  if (UDP_CONNECTION_REQUEST_PORT) {
    client.bind({
      port: UDP_CONNECTION_REQUEST_PORT,
      exclusive: true
    });
  }
  count = 3;
  client.send(message, 0, message.length, port, host, f = function(err) {
    if (err || --count <= 0) {
      client.close();
      return callback(err);
    }
    return client.send(message, 0, message.length, port, host, f);
  });
  return true;
};

httpConReq = function(url, username, password, allowBasicAuth, timeout, callback) {
  var options, request, statusToError;
  options = URL.parse(url);
  if (options.protocol !== 'http:') {
    return callback(new Error('Invalid connection request URL or protocol'));
  }
  options.agent = new http.Agent({
    maxSockets: 1
  });
  statusToError = function(statusCode) {
    switch (statusCode) {
      case 200:
      case 204:
        return null;
      case 401:
        return new Error('Incorrect connection request credentials');
      case 0:
        return new Error('Device is offline');
      default:
        return new Error("Unexpected response code from device: " + statusCode);
    }
  };
  return request = http.get(options, function(res) {
    var authHeader;
    if (res.statusCode === 401 && (res.headers['www-authenticate'] != null)) {
      authHeader = auth.parseAuthHeader(res.headers['www-authenticate']);
      if (authHeader.method === 'Basic') {
        if (!allowBasicAuth) {
          request.abort();
          callback(new Error('Basic HTTP authentication not allowed'));
          return;
        }
        options.headers = {
          'Authorization': auth.basic(username || '', password || '')
        };
      } else if (authHeader.method === 'Digest') {
        options.headers = {
          'Authorization': auth.digest(username || '', password || '', options.path, 'GET', null, authHeader)
        };
      }
      request = http.get(options, function(res) {
        if (res.statusCode === 0) {
          request = http.get(options, function(res) {
            callback(statusToError(res.statusCode));
            return res.resume();
          }).on('error', function(err) {
            request.abort();
            return callback(statusToError(0));
          }).on('socket', function(socket) {
            socket.setTimeout(timeout);
            return socket.on('timeout', function() {
              return request.abort();
            });
          });
        } else {
          callback(statusToError(res.statusCode));
        }
        return res.resume();
      }).on('error', function(err) {
        request.abort();
        return callback(statusToError(0));
      }).on('socket', function(socket) {
        socket.setTimeout(timeout);
        return socket.on('timeout', function() {
          return request.abort();
        });
      });
    } else {
      callback(statusToError(res.statusCode));
    }
    return res.resume();
  }).on('error', function(err) {
    request.abort();
    return callback(statusToError(0));
  }).on('socket', function(socket) {
    socket.setTimeout(timeout);
    return socket.on('timeout', function() {
      return request.abort();
    });
  });
};

connectionRequest = function(deviceId, callback) {
  var CONNECTION_REQUEST_ALLOW_BASIC_AUTH, CONNECTION_REQUEST_TIMEOUT, proj;
  CONNECTION_REQUEST_TIMEOUT = config.get('CONNECTION_REQUEST_TIMEOUT', deviceId);
  CONNECTION_REQUEST_ALLOW_BASIC_AUTH = config.get('CONNECTION_REQUEST_ALLOW_BASIC_AUTH', deviceId);
  proj = {
    'Device.ManagementServer.ConnectionRequestURL._value': 1,
    'Device.ManagementServer.UDPConnectionRequestAddress._value': 1,
    'Device.ManagementServer.ConnectionRequestUsername._value': 1,
    'Device.ManagementServer.ConnectionRequestPassword._value': 1,
    'InternetGatewayDevice.ManagementServer.ConnectionRequestURL._value': 1,
    'InternetGatewayDevice.ManagementServer.UDPConnectionRequestAddress._value': 1,
    'InternetGatewayDevice.ManagementServer.ConnectionRequestUsername._value': 1,
    'InternetGatewayDevice.ManagementServer.ConnectionRequestPassword._value': 1
  };
  return db.devicesCollection.findOne({
    _id: deviceId
  }, proj, function(err, device) {
    var conReq, connectionRequestUrl, password, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, udpConnectionRequestAddress, username;
    if (err) {
      return callback(err);
    }
    if (!device) {
      return callback(new Error("No such device"));
    }
    if (device.Device != null) {
      connectionRequestUrl = device.Device.ManagementServer.ConnectionRequestURL._value;
      udpConnectionRequestAddress = (ref = device.Device.ManagementServer) != null ? (ref1 = ref.UDPConnectionRequestAddress) != null ? ref1._value : void 0 : void 0;
      username = (ref2 = device.Device.ManagementServer.ConnectionRequestUsername) != null ? ref2._value : void 0;
      password = (ref3 = device.Device.ManagementServer.ConnectionRequestPassword) != null ? ref3._value : void 0;
    } else {
      connectionRequestUrl = device.InternetGatewayDevice.ManagementServer.ConnectionRequestURL._value;
      udpConnectionRequestAddress = (ref4 = device.InternetGatewayDevice.ManagementServer) != null ? (ref5 = ref4.UDPConnectionRequestAddress) != null ? ref5._value : void 0 : void 0;
      username = (ref6 = device.InternetGatewayDevice.ManagementServer.ConnectionRequestUsername) != null ? ref6._value : void 0;
      password = (ref7 = device.InternetGatewayDevice.ManagementServer.ConnectionRequestPassword) != null ? ref7._value : void 0;
    }
    conReq = function() {
      var udpSent;
      udpSent = udpConReq(udpConnectionRequestAddress, username, password, function(err) {
        if (err) {
          throw err;
        }
      });
      return httpConReq(connectionRequestUrl, username, password, CONNECTION_REQUEST_ALLOW_BASIC_AUTH, CONNECTION_REQUEST_TIMEOUT, function(err) {
        if (udpSent) {
          return callback();
        }
        return callback(err);
      });
    };
    if (((ref8 = config.auth) != null ? ref8.connectionRequest : void 0) != null) {
      if (config.auth.connectionRequest.length > 4) {
        return config.auth.connectionRequest(deviceId, connectionRequestUrl, username, password, function(u, p) {
          username = u;
          password = p;
          return conReq();
        });
      }
      ref9 = config.auth.connectionRequest(deviceId, connectionRequestUrl, username, password), username = ref9[0], password = ref9[1];
    }
    return conReq();
  });
};

watchTask = function(deviceId, taskId, timeout, callback) {
  return setTimeout(function() {
    return db.tasksCollection.findOne({
      _id: taskId
    }, {
      '_id': 1
    }, function(err, task) {
      if (err) {
        return callback(err);
      }
      if (!task) {
        return callback(null, 'completed');
      }
      return db.faultsCollection.findOne({
        _id: deviceId + ":task_" + taskId
      }, {
        '_id': 1
      }, function(err, fault) {
        if (err) {
          return callback(err);
        }
        if (fault) {
          return callback(null, 'fault');
        }
        if ((timeout -= 500) <= 0) {
          return callback(null, 'timeout');
        }
        return watchTask(deviceId, taskId, timeout, callback);
      });
    });
  }, 500);
};

sanitizeTask = function(task, callback) {
  var ref;
  task.timestamp = new Date((ref = task.timestamp) != null ? ref : Date.now());
  if (task.expiry != null) {
    if (common.typeOf(task.expiry) === common.DATE_TYPE || isNaN(task.expiry)) {
      task.expiry = new Date(task.expiry);
    } else {
      task.expiry = new Date(task.timestamp.getTime() + +task.expiry * 1000);
    }
  }
  return callback(task);
};

insertTasks = function(tasks, callback) {
  var counter, i, len, results, task;
  if ((tasks != null) && common.typeOf(tasks) !== common.ARRAY_TYPE) {
    tasks = [tasks];
  } else if ((tasks == null) || tasks.length === 0) {
    return callback(null, tasks || []);
  }
  counter = tasks.length;
  results = [];
  for (i = 0, len = tasks.length; i < len; i++) {
    task = tasks[i];
    results.push(sanitizeTask(task, function(t) {
      if (t.uniqueKey != null) {
        db.tasksCollection.remove({
          device: t.device,
          uniqueKey: t.uniqueKey
        }, function(err) {});
      }
      --counter;
      if (counter === 0) {
        return db.tasksCollection.insert(tasks, function(err, _tasks) {
          return callback(err, _tasks);
        });
      }
    }));
  }
  return results;
};

deleteDevice = function(deviceId, callback) {
  return db.tasksCollection.remove({
    'device': deviceId
  }, function(err) {
    if (err) {
      return callback(err);
    }
    return db.devicesCollection.remove({
      '_id': deviceId
    }, function(err) {
      if (err) {
        return callback(err);
      }
      return db.faultsCollection.remove({
        '_id': {
          '$regex': "^" + (common.escapeRegExp(deviceId)) + "\\:"
        }
      }, function(err) {
        if (err) {
          return callback(err);
        }
        return db.operationsCollection.remove({
          '_id': {
            '$regex': "^" + (common.escapeRegExp(deviceId)) + "\\:"
          }
        }, function(err) {
          if (err) {
            return callback(err);
          }
          return cache.del(deviceId + "_tasks_faults_operations", callback);
        });
      });
    });
  });
};

exports.connectionRequest = connectionRequest;

exports.watchTask = watchTask;

exports.insertTasks = insertTasks;

exports.deleteDevice = deleteDevice;
