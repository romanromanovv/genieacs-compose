// Generated by CoffeeScript 1.12.7

/*
 * Copyright 2013-2017  Zaid Abdulla
 *
 * This file is part of GenieACS.
 *
 * GenieACS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * GenieACS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with GenieACS.  If not, see <http://www.gnu.org/licenses/>.
 */
var cache, closeServer, cluster, config, db, exit, extensions, fs, httpsCa, httpsCert, httpsKey, listener, logger, networkInterface, onConnection, options, path, port, server, service, useHttps, util;

service = process.argv[2];

if (service == null) {
  throw new Error('Missing argument cwmp, fs, or nbi');
}

util = require('util');

cluster = require('cluster');

logger = require('./logger');

logger.init(service, require('../package.json').version);

config = require('./config');

db = require('./db');

cache = require('./cache');

extensions = require('./extensions');

networkInterface = config.get((service.toUpperCase()) + "_INTERFACE");

port = config.get((service.toUpperCase()) + "_PORT");

useHttps = config.get((service.toUpperCase()) + "_SSL");

listener = require("./" + service).listener;

onConnection = require("./" + service).onConnection;

server = null;

closeServer = function(timeout, callback) {
  if (!server) {
    return callback();
  }
  setTimeout(function() {
    var cb;
    if (!callback) {
      return;
    }
    server.removeListener('request', listener);
    server.setTimeout(1);
    cb = callback;
    callback = null;
    return setTimeout(cb, 1000);
  }, timeout).unref();
  return server.close(function() {
    var cb;
    if (!callback) {
      return;
    }
    cb = callback;
    callback = null;
    return cb();
  });
};

exit = function() {
  setTimeout(function() {
    return extensions.killAll(function() {
      return process.exit(1);
    });
  }, 30000).unref();
  return closeServer(20000, function() {
    var ref;
    db.disconnect();
    cache.disconnect();
    extensions.killAll();
    return (ref = cluster.worker) != null ? ref.disconnect() : void 0;
  });
};

process.on('uncaughtException', function(err) {
  logger.error({
    message: 'Uncaught exception',
    exception: err,
    pid: process.pid
  });
  return exit();
});

if (useHttps) {
  path = require('path');
  fs = require('fs');
  httpsKey = path.resolve(config.get('CONFIG_DIR'), service + ".key");
  httpsCert = path.resolve(config.get('CONFIG_DIR'), service + ".crt");
  httpsCa = path.resolve(config.get('CONFIG_DIR'), service + ".ca-bundle");
  options = {
    key: fs.readFileSync(httpsKey),
    cert: fs.readFileSync(httpsCert)
  };
  try {
    options.ca = fs.readFileSync(httpsCa).toString().match(/\-+BEGIN CERTIFICATE\-+[0-9a-zA-Z\+\-\/\=\s]+?\-+END CERTIFICATE\-+/g);
  } catch (error) {}
  server = require('https').createServer(options, listener);
  if (onConnection != null) {
    server.on('secureConnection', onConnection);
  }
} else {
  server = require('http').createServer(listener);
  if (onConnection != null) {
    server.on('connection', onConnection);
  }
}

db.connect(function(err) {
  if (err) {
    throw err;
  }
  return cache.connect(function(err) {
    if (err) {
      throw err;
    }
    return server.listen(port, networkInterface);
  });
});

process.on('SIGINT', exit);

process.on('SIGTERM', exit);
